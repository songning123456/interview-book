#### 分布式事务实现的几种方案
*  **两阶段提交方案/XA方案**
<div style="text-indent:2em">这种分布式事务方案，比较适合单块应用里。跨多个库的分布式事务，由于因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 Spring + JTA 就可以搞定。这个方案，很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。如果你要操作别人的服务的库，你必须是通过调用别的服务的接口来实现，绝对不允许交叉访问别人的数据库。</div>
    
    
* **TCC(Try, Confirm, Cancel)方案**
  1. 使用补偿机制,分三个阶段
    * Try阶段: 这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。
    * Confirm阶段: 这个阶段说的是在各个服务中执行实际的操作。
    * Cancel阶段: 如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。(把那些执行成功的回滚)
  2. 缺点
  <div style="text-indent:2em">与业务耦合太紧，事务回滚严重依赖自己的写的代码来回滚和补偿。</div>
  3. 适用场景
  <div style="text-indent:2em">与钱打交道的场景，支付，交易。需要TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性。</div>


* **本地消息表**
  1. 流程
    * A系统在处理本地事务的同时插入一条数据到消费表。
    * 然后A系统将这个消息发送到MQ。
    * B系统接收到消息后，在一个事务里，先往自己本地消息表插入一条记录，然后执行业务处理；如果这个消息已经被处理过，则消息表插入失败，事务回滚，保证不会重复处理消息。
    * 如果B系统处理成功，则更新自己本地消费表状态和A系统消费表状态。
    * 如果B系统处理失败，则不会更新消息表状态，A系统会定期扫描自己的消息表，如果有未处理的消息，会再次发送到MQ中，让B系统再次处理。
    * 这个方案保证最终一致性，哪怕B系统事务失败，但A会不断重发消息，直到B成功为止。
  2. 缺点
  <div style="text-indent:2em">严重依赖数据库的消息表来管理事务。高并发场景怎么办，访问消息表瓶颈，不容易扩展。</div>
    
    
* **可靠消息最终一致性方案(国内互联网流行)**
![1266003526429966358](/images/SpringCloud/1266003526429966358.png)
  1. 定义
  <div style="text-indent:2em">不用本地消费表，直接基于MQ来实现事务。比如阿里的RocketMQ就支持消息事务。</div>
  2. 流程
    * A系统发一个prepared消息到MQ，如果这个消息失败则直接取消操作。
    * 如果这个prepared消息发送成功，则执行本地事务，如果事务执行成功就发送confirm消息到MQ，如果失败就告诉MQ回滚消息。
    * 如果发送了confirm消息，则MQ让B系统消费这条confirm消息，然后执行本地事务。
    * MQ会定时轮询所有prepared消息，然后回调A系统接口，查看这个消息是回滚还是要重发一次confirm消息。一般情况A系统查看本地事务是否执行成功，如果回滚了，则消息也回滚。避免本地事务执行成功，而confirm消息发送失败。
    * 如果B系统事务失败，则不断重试直到成功。如果实在不行，则想办法通知A系统回滚，或发送报警由人工来手动回滚或补偿。
        
        
#### 你们公司怎么处理分布式事务?
<div style="text-indent:2em">如果是严格资金场景，用的TCC方案； 如果是订单插入之后要调用库存服务更新库存，可以用可靠消息最终一致性方案。一般情况不应该使用分布式事务，代码复杂，性能太差。普通的A调用B，C，D，根本不用做分布式事务。一般就是监控(发邮件，发短信报警)，记录日志(一旦出错，完整的日志)，事后快速的定位，排查和解决方案，临时修复数据。比做分布式事务的成本要低很多。</div>


#### CAP理论
![1266003526497075204](/images/SpringCloud/1266003526497075204.png)


* 定义
  * C: Consistency一致性
  * A: Availability可用性
  * P: Partition tolerance分区容错性
  
  
* 定理
<div style="text-indent:2em">一个分布式系统不可能同时满足CAP三个要求，最多只能同时满足其中两项</div>
* 选择
  * CA
 <div style="text-indent:2em">放弃分区容错性，所有数据放一个节点，退回单机模式。</div>
  * CP
 <div style="text-indent:2em">放弃可用性，一旦网络故障，受影响服务需要等待恢复时间，系统处于不可用状态。</div>
  * AP
 <div style="text-indent:2em">放弃一致性，这里指放弃强一致性，确保最终一致性。大多数分布式系统的选择。</div>
    
    
#### BASE理论
* 定义
  * BASE: Base Available(基本可用)
  * Soft state(软状态)
  * Eventually consistent(最终一致性)
  
  
* BASE是对CAP一致性和可用性权衡的结果
  * 基本可用
  <div style="text-indent:2em">指分布式系统出现不可预知故障时，允许损失部分可用性，响应时间合理延长，服务上适当降级。</div>
  * 软状态
  <div style="text-indent:2em">允许分布式系统中的数据处于中间状态，允许各节点数据同步时存在延时。</div>
  * 最终一致性
  <div style="text-indent:2em">允许系统中所有数据副本，在经过一段时间同步后，最终能够达到一个一致的状态。不需要实时保证系统的数据一致性。</div>


#### 两阶段提交(2PC)
数据库支持2PC，又叫XA transactions。MySQL从5.5版，Oracle从7版，SQL Server 2005开始支持。


* XA是一个两阶段提交协议，协议分两阶段
  1. 第一阶段: 
  <div style="text-indent:2em">事务协调器要求每个涉及到事务的数据库预提交/投票(pre commit)此操作，并反映是否可以提交。</div>
  2. 第二阶段: 
  <div style="text-indent:2em">事务协调器要求每个数据库提交数据。</div>
  <div style="text-indent:2em">如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。</div>
  
  
* 预提交/投票阶段
![1266003526555795492](/images/SpringCloud/1266003526555795492.png)
<div style="text-indent:2em">事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交。</div>


* 提交阶段
![1266003526614515725](/images/SpringCloud/1266003526614515725.png)
<div style="text-indent:2em">如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</div>


* 2PC缺点
  1. 同步阻塞
    执行过程中，所有节点都是事务阻塞的。
  2. 单点故障
    * 协调者正常，参与者宕机
    协调者无法收集到所有参与者反馈，会陷入阻塞。
    * 协调者宕机，参与者正常
    无论哪个阶段，协调者挂了，则无法发送提交请求，参与者会陷入阻塞。
    * 协调者与参与者都宕机
    <div>发生在第一阶段，由于参与者都没有真正commit，则可以重新选出协调者，再执行2PC。</div>
    <div>发生在第二阶段，并且挂了的参与者在挂之前并没有收到协调者指令。这种情况，新的协调者重新执行2PC。</div>
    <div>发生在第二阶段，有部分参与者已经commit，产生数据不一致(脑裂)。2PC无法解决！</div>
    <div>协调者发出commit后挂了，唯一接收到这条消息的参与者同时也挂了。则即使选举出新的协调者，这条事务状态也不确定，没人知道事务是否被已经提交。</div>
       
       
#### 三阶段提交(3PC)
* 改进点
  1. 同时在协调者和参与者引入超时机制。
  2. 在2PC的第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与者状态时一致的。
  
  
* 三个阶段
  1. CanCommit阶段
  <div style="text-indent:2em">2PC的第一阶段是本地事务执行结束后，最后不Commit。3PC的CanCommit是指尝试获取数据库锁，如果可以就返回Yes，进入预备状态，否则返回No。</div>
  2. PreCommit阶段
  <div style="text-indent:2em">如果上一阶段所有参与者都返回Yes，则进入PreCommit阶段进行事务预提交。这里协调者和参与者都引入超时机制。假如有任何一个参与者向协调者发送No，或者等待超时之后，协调者还没有收到参与者响应，则执行事务中断。</div>
  3. DoCommit阶段
    真正进行事务提交,包括:
    * 协调者发送提交请求；
    * 参与者提交事务；
    * 参会者响应反馈(向协调者发送ACK)；
    * 协调者确定事务完成。
    
        
#### TCC事务
* 定义
Try/Confirm/Cancel，可归纳为补偿型事务。
  1. Try
  <div style="text-indent:2em">针对业务操作做检测(一致性)和资源预留(隔离性)。</div>
  2. Confirm
  <div style="text-indent:2em">对业务进行确认提交。默认Try成功并开始执行Confirm，Confirm一定成功。</div>
  3. Cancel
  <div style="text-indent:2em">在业务执行错误，需要回滚时执行业务补偿，释放预留资源。</div>
  
  
* 核心思想
<div style="text-indent:2em">针对每个操作，都有有一个与其对应的确认和补偿(撤销)操作。</div>


* 优点
  1. 解决协调者单点故障的问题。
  2. 引入超时后进行补偿，并不会锁定整个资源，事务颗粒的变小。
  3. 通过补偿机制，由业务操作管理数据一致性。
  
  
* 缺点
<div style="text-indent:2em">开发复杂，每个目标字段都需要一个预留(冻结)字段，需要写很多补偿代码，在一些业务场景不太好定义和处理。</div> 


* 使用场景
<div style="text-indent:2em">钱，金融等对事务要求非常高的核心业务场景。</div>


#### 总结
<div style="text-indent:2em">TCC使用于大部分接口是同步调用的场景，要么一起成功，要么一起回滚。但在实际系统中，可能服务之间的调用时异步的，通过消息中间件。</div>
    
    