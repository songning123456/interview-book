#### 定义
<div style="text-indent:2em">SnowFlake算法生成id的结果是一个64bit大小的整数, 其中的41位时间戳部分依赖服务器的时间, 当服务器发生时钟回拨时, 在开源的实现中不可避免的会出现报错. 关于解决时钟回拨的问题, 网上已有各种方案, 比如适当等待直到时间被追回, 在内存中保存一段时间内使用过的最大序列号</div>
   
#### 方案
<div style="text-indent:2em"> 首先, SnowFlake的末尾12位是序列号, 用来记录同一毫秒内产生的不同id, 同一毫秒总共可以产生4096个id, 每一毫秒的序列号都是从0这个基础序列号开始递增假设我们的业务系统在单机上的QPS为3w/s, 那么其实平均每毫秒只需要产生30个id即可, 远没有达到设计的4096, 也就是说通常情况下序列号的使用都是处在一个低水位, 当发生时钟回拨的时候, 这些尚未被使用的序号就可以派上用场了.因此, 可以对给定的基础序列号稍加修改, 后面每发生一次时钟回拨就将基础序列号加上指定的步长, 例如开始时是从0递增, 发生一次时钟回拨后从1024开始递增, 再发生一次时钟回拨则从2048递增, 这样还能够满足3次的时钟回拨到同一时间点(发生这种操作就有点扯了)。</div>
   