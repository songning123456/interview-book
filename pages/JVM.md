#### 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。


Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。


#### JDK和JRE的区别是什么？
Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。


#### Java中垃圾回收有什么目的？什么时候进行垃圾回收？
垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。


#### System.gc()和Runtime.gc()会做什么事情？
这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。


#### finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？
在释放对象占用的内存之前，垃圾收集器会调用对象的finalize()方法。一般建议在该方法中释放对象持有的资源。


#### 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？
不会，在下一个垃圾回收周期中，这个对象将是可被回收的。


#### Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)? 
JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。


堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。


#### 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？
吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。


#### 在Java中，对象什么时候可以被垃圾回收？
当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。


#### JVM的永久代中会发生垃圾回收么？
垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。


#### 怎么解决内存泄露问题？
内存泄漏是指应用程序未清除无效的内存，内存泄漏并非指物理上面的内存消失，而是应用程序分配了某段内存后，由于设计的错误，失去了对该内存的控制，造成了内存浪费！第一，良好的编码习惯，尽量在涉及内存的程序段，检测出内存泄露。当程式稳定之后，在来检测内存泄露时，无疑增加了排除的困难和复杂度。


#### 类加载原理？
类加载器是一个用来加载类文件的类，类加载的原理基于三个机制：委托，可见性和单一性。


| 机制 | 解释 | 
| :----- | :----- | 
| 委托机制 | 将加载一个类的请求交给父类加载器，如果这个父类加载器不能够找到或者加载这个类，那么再加载它 | 
| 可见性 | 子类的加载器可以看见所有父类的加载器加载的类，而父类加载器看不到子类加载器加载的类 | 
| 单一性 | 加载一个类一次，这是有委托机制确保子类加载器不会再次加载父类加载器加载过的类 | 


| 预定义类加载器 | 解释 | 
| :----- | :----- | 
| 启动类加载器(BootStrap) | 引导类装入器是用本地代码实现的类装入器，它负责将Java_Runtime_Home/lib下面的核心类库或-Xbootclasspath选项指定的jar包加载到内存中 | 
| 扩展类加载器(Extension) | 扩展类加载器是用Sun的ExtClassLoader实现的，他负责将Java_Runtime_Home/lib/ext或者是由系统变量-Djava.ext.dir指定位置中的类库加载到内存中 | 
| 系统类加载器(System) | 由Sun的AppClassLoader实现的，负责将系统类路径java-classpath或者-Djava.class.path变量所指定的目录下的类库加载到内存中 | 


#### 代码执行顺序？
父类静态代码块 -> 子类静态代码块 -> 父类构造代码块 -> 父类构造函数 -> 子类构造代码块 -> 子类构造函数。


简单来说就是先执行静态代码块，再执行父类的构造代码块和构造函数，最后执行子类的构造代码块和构造函数。


#### Java虚拟机的运行时数据区有几块？线程私有和线程共享区域有哪些？
| 区域 | 私有/公有 | 解释 | 
| :----- | :----- | :----- | 
| 程序计数器 | 私有 | 当前线程执行的字节码的行号指示器 | 
| Java虚拟机栈 | 私有 | 存放基本数据类型、对象引用和returnAddress类型 | 
| 本地方法栈 | 私有 | 为虚拟机使用到的Native方法服务 | 
| Java堆 | 公有 | 存放对象的实例，也是GC回收器管理的主要区域 | 
| 方法区 | 公有 | 存放已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据 | 
| 运行时常量池 | ———— | 方法区的一部分，存放编译期生成的各种字面量和符号引用 | 
| 直接内存 | ———— | 不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，容易引起OOM异常，NIO会调用，不受Java堆大小的限制 | 