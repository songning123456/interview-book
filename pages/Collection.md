#### Java集合类框架的基本接口有哪些？
| 接口 | 解释 | 
| :----- | :----- | 
| Collection | 代表一组对象，每一个对象都是它的子元素  | 
| Set | 不包含重复元素的Collection | 
| List | 有顺序的collection，并且可以包含重复元素 | 
| Map | 可以把键(key)映射到值(value)的对象，键不能重复 | 


#### 为什么集合类没有实现Cloneable和Serializable接口？
集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。


#### 什么是迭代器(Iterator)？
Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。


克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。


#### Iterator和ListIterator的区别是什么？
| Iterator | ListIterator |
| :----- | :----- |
| 可用来遍历Set和List集合 | 只能用来遍历List |
| 对集合只能是前向遍历 | 既可以前向也可以后向 |
| 实现了Iterator接口，并包含其他的功能。比如增加元素，替换元素，获取前一个和后一个元素的索引等等 | ———— |


#### 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？
Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。


#### Java中的HashMap的工作原理是什么？
Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。


#### hashCode()和equals()方法的重要性体现在什么地方？
Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。


#### HashMap和Hashtable有什么区别？
| HashMap | Hashtable | 
| :----- | :----- | 
| 允许键和值是null | 不允许键或者值是null | 
| 非同步，适合于单线程环境 | 同步，适合于多线程环境 |
| 可供应用迭代的键的集合，因此，HashMap是快速失败的 | 对键的列举(Enumeration) |


#### HashMap的结构？
数组+链表+红黑树。


数组中每个元素都是一个链表,HashMap是基于hash原理：我们对map进行put的时候，会对键调用hashcode方法，通过hashcode获得bucket，从而存储entry。 


#### 如何避免hashcode相同导致的冲突，如何存储这些冲突元素，找到这些元素？
因为他们的hashcode相同,所有他们的bucket位置相同,会产生碰撞,采用合适的equal和hashcode会减少碰撞,使用integer和String(warping)可以提高查找效律。


因为HashMap采用链表储存对象,所有entry会储存在链表中。找到bucket位置后，可以调用key.equal()方法找到链表中正确的节点，从而找到值对象。


#### TreeMap结构，如何实现有序的？
TreeMap基于红黑树(Red-Black tree)实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的Comparator进行排序，具体取决于使用的构造方法。


#### 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？
| Array | ArrayList | 
| :----- | :----- |
| 可以包含基本类型和对象类型 | 只能包含对象类型 | 
| 大小是固定的 | 大小是动态变化的 | 
| 提供了更多的方法和特性。比如addAll()，removeAll()，iterator()等等 | ———— | 


对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。


#### ArrayList和LinkedList有什么区别？
| ArrayList | LinkedList | 
| :----- | :----- | 
| 基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问 | 以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n) | 
| ———— | 插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引 | 
| ———— | LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素 |


#### Comparable和Comparator接口是干什么的？列出它们的区别？
Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。


Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。


#### 什么是Java优先级队列(Priority Queue)？
PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。


#### 你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？
大O符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。


大O符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大O符号基于时间，内存和性能来选择最好的实现。大O符号可以对大量数据的性能给出一个很好的说明。


#### 如何权衡是使用无序的数组还是有序的数组？
| 有序数组 | 无序数组 | 
| :----- | :----- | 
| 查找的时间复杂度是O(log n) | 查找的时间复杂度是O(n) | 
| 插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置 | 插入时间复杂度是常量O(1) | 


#### Java集合类框架的最佳实践有哪些？
根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。


有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。


为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。


使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。


编程的时候接口优于实现。


底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。


#### Enumeration接口和Iterator接口的区别有哪些？
| Enumeration | Iterator | 
| :----- | :----- | 
| 速度是Iterator的2倍，同时占用更少的内存 | ———— | 
| ———— | 比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象 | 
| ———— | 允许调用者删除底层集合里面的元素 |


#### HashSet和TreeSet有什么区别？
| HashSet | TreeSet | 
| :----- | :----- | 
| 由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1) | 由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(log n) | 


