#### Redis持久化机制？


Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。


**RDB**是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。(快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。)


**AOF**持久化，Redis会将每一个收到的写命令都通过write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。


当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。


#### 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级问题？
| 问题 | 定义 | 解决办法 | 
| :----- | :----- | :----- | 
| <div style="width: 65px">缓存雪崩</div> | <div style="width: 300px">由于原有缓存失效，新缓存未到期间(例如我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃</div> | 大多数系统设计者考虑用加锁(最多的解决方案)或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开 |
| <div style="width: 65px">缓存穿透</div> | <div style="width: 300px">用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空(相当于进行了两次无用的查询)。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题</div> | 最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空(不管是数据不存在，还是系统故障)，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。Bitmap典型的就是哈希表缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间和时间来完成了 |
| <div style="width: 65px">缓存预热</div> | <div style="width: 300px">系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据</div> | 直接写个缓存刷新页面，上线时手工操作下；数据量不大，可以在项目启动的时候自动进行加载；定时刷新缓存 |
| <div style="width: 65px">缓存更新</div> | <div style="width: 300px">除了缓存服务器自带的缓存失效策略之外(Redis默认的有6中策略可供选择)，我们还可以根据具体的业务需求进行自定义的缓存淘汰</div> | 定时去清理过期的缓存；当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂 |
| <div style="width: 65px">缓存降级</div> | <div style="width: 300px">当访问量剧增、服务出现问题(如响应时间慢或不响应)或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的</div> | 服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是Redis出现问题，不去数据库查询，而是直接返回默认值给用户 |


#### 热点数据和冷数据是什么？
热点数据，缓存才有价值。


对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存。


对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。


数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。


#### Memcache与Redis的区别都有哪些？
| —— | Redis | Memcache | 
| :----- | :----- | :----- | 
| <div style="width: 140px">存储方式</div> | 部份存在硬盘上，redis可以持久化其数据 | 数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小 |
| <div style="width: 140px">数据支持类型</div> | 支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储 | 所有的值均是简单的字符串 |
| <div style="width: 140px">底层模型/通信应用协议</div> | 直接自己构建了VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求 | —— |
| <div style="width: 140px">value值大小不同</div> | 最大可以达到512M | 只有1MB |
| <div style="width: 140px">速度</div> | 快 | 慢 |
| <div style="width: 140px">数据备份</div> | 支持master-slave模式的数据备份 | —— |


#### 单线程的redis为什么这么快？
* 纯内存操作
* 单线程操作，避免了频繁的上下文切换
* 采用了非阻塞I/O多路复用机制


#### redis的数据类型，以及每种数据类型的使用场景？
| 名称 | 解释 |
| :----- | :----- |
| <div style="width: 75px">string</div> | 最常规的set/get操作，value可以是string也可以是数字。一般做一些复杂的计数功能的缓存 |
| <div style="width: 75px">hash</div> | 这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果 |
| <div style="width: 75px">list</div> | 使用list的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则 |
| <div style="width: 75px">set</div> | 因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了 |
| <div style="width: 75px">sorted set</div> | sorted set多了一个权重参数score，集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作 |