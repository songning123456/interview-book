#### 进程和线程的区别是什么？
进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。


#### 创建线程有几种不同的方式？你喜欢哪一种？为什么？
有三种方式可以用来创建线程。


继承Thread类，实现Runnable接口，应用程序可以使用Executor框架来创建线程池。


实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承(而Java不支持多继承)，只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。


#### 概括的解释下线程的几种可用状态。
| 状态 | 解释 | 
| :---- | :---- |
| 就绪(Runnable) | 线程准备运行，不一定立马就能开始执行 |
| 运行中(Running) | 进程正在执行线程的代码 |
| 等待中(Waiting) | 线程处于阻塞的状态，等待外部的处理结束 |
| 睡眠中(Sleeping) | 线程被强制睡眠 |
| I/O阻塞(Blocked on I/O) | 等待I/O操作完成 |
| 同步阻塞(Blocked on Synchronization) | 等待获取锁 |
| 死亡(Dead) | 线程完成了执行 |


#### 什么是线程安全?
线程安全就是多线程访问同一代码，不会产生不确定的结果。


#### 如何保证线程安全?
对非安全的代码进行加锁控制。


使用线程安全的类。


多线程并发情况下，线程共享的变量改为方法级的局部变量。


#### 怎么停止一个线程？
使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。


使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。


使用interrupt方法中断线程。


#### sleep和wait的区别？
| sleep | wait | 
| :----- | :----- | 
| Thread类中方法 | Object类中的方法 | 
| 可以在任何地方使用 | 只能在同步代码块或同步方法中使用 | 
| 程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态，在调用sleep()方法的过程中，线程不会释放对象锁 | 线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备 | 


#### 多线程之间是如何进行信息交互的？
| 方法 | 解释 | 
| :----- | :----- | 
| void notify() | 唤醒在此对象监视器上等待的单个线程 | 
| void notifyAll() | 唤醒在此对象监视器上等待的所有线程 | 
| void wait() | 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法 | 
| void wait(long timeout) | 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量 | 
| void wait(long timeout,int nanos) | 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量 | 