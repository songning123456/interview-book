#### 说一下ArrayList和LinkedList区别
1. 首先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的。
2. 由于底层数据结构不同，他们所适用的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不同。
3. 另外ArrayList和LinkedList都实现了List接口，但是LinkedList还额外实现了Deque接口，所以LinkedList还可以当做队列来使用。


#### 说一下HashMap的put()方法
1. 首先put()方法接收到key和value时，会先利用key进行哈希算法得到这个key对应的哈希值。
2. 再通过这个哈希值与数组长度-1进行与操作得到一个数组下标。
3. 再判断数组下标位置是不是空着，如果空着，则直接把key和value封装为一个Node对象并存入此数组位置。
4. 如果此下标位置上非空，表示此位置上存在Node对象，那么则判断该Node对象是不是一个红黑树节点，如果是则将key和value封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value。
5. 如果此位置上的Node对象是链表节点，则将key和value封装为一个链表Node并插入到链表中去。
6. 插入到链表中后，会判断链表的节点个数是不是超过了8个，如果超过则把当前位置的链表转化为红黑树。
7. 插入链表使用的是尾插法，所以需要遍历链表，而在这个过程中也会去判断key是否存在，如果存在则更新value。


#### 说一下ThreadLocal
1. ThreadLocal是Java中所提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据。
2. ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象(注意不是ThreadLocal对象)中都存在一个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值。
3. 如果在线程池中使用ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使用完之后，应该要把设置的key、value，也就是Entry对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap，ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏，解决办法是，在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清除Entry对象。
4. ThreadLocal经典的应用场景就是连接管理(一个线程持有一个连接，该连接对象可以在不同的方法之间进行传递，线程之间不共享同一个连接)。


#### 说一下JVM中，哪些是共享区，哪些可以作为gc root
1. 堆区和方法区是所有线程共享的，栈、本地方法栈、程序计数器是每个线程独有的。
2. 什么是gc root，JVM在进行垃圾回收时，需要找到“垃圾”对象，也就是没有被引用的对象，但是直接找“垃圾”对象是比较耗时的，所以反过来，先找“非垃圾”对象，也就是正常对象，那么就需要从某些“根”开始去找，根据这些“根”的引用路径找到正常对象，而这些“根”有一个特征，就是它只会引用其他对象，而不会被其他对象引用，例如：栈中的本地变量、方法区中的静态变量、本地方法栈中的变量、正在运行的线程等可以作为gc root。


#### 你们项目如何排查JVM问题
对于还在正常运行的系统:


1. 可以使用jmap来查看JVM中各个区域的使用情况。
2. 可以通过jstack来查看线程的运行情况，比如哪些线程阻塞、是否出现了死锁。
3. 可以通过jstat命令来查看垃圾回收的情况，特别是fullgc，如果发现fullgc比较频繁，那么就得进行调优了。
4. 通过各个命令的结果，或者jvisualvm等工具来进行分析。
5. 首先，初步猜测频繁发送fullgc的原因，如果频繁发生fullgc但是又一直没有出现内存溢出，那么表示fullgc实际上是回收了很多对象了，所以这些对象最好能在younggc过程中就直接回收掉，避免这些对象进入到老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入到了老年代，尝试加大年轻代的大小，如果改完之后，fullgc减少，则证明修改有效。
6. 同时，还可以找到占用CPU最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存。


对于已经发生了OOM的系统:


1. 一般生产系统中都会设置当系统发生了OOM时，生成当时的dump文件(-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/base)。
2. 我们可以利用`jvisualvm`等工具来分析dump文件。
3. 根据dump文件找到异常的实例对象和异常的线程(占用CPU高)，定位到具体的代码。
4. 然后再进行详细的分析和调试。


总之，调优不是一蹴而就的，需要分析、推理、实践、总结、再分析，最终定位到具体的问题。


#### 如何查看线程死锁
1. 可以通过jstack命令来进行查看，jstack命令中会显示发生了死锁的线程。
2. 或者两个线程去操作数据库时，数据库发生了死锁，这是可以查询数据库的死锁情况。
```sql
# 查询是否锁表
show OPEN TABLES where In_use>0;
# 查询进程
show processlist;
# 查看正在锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
# 查看等待锁的事务
SELECT *FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
```


#### 线程之间如何进行通讯的
1. 线程之间可以通过共享内存或基于网络来进行通信。
2. 如果是通过共享内存来进行通信，则需要考虑并发问题，什么时候阻塞，什么时候唤醒。
3. 像Java中的wait()、notify()就是阻塞和唤醒。
4. 通过网络就比较简单了，通过网络连接将通信数据发送给对方，当然也要考虑到并发问题，处理方式就是加锁等方式。


#### 介绍一下Spring，读过源码介绍一下大致流程
1. Spring是一个快速开发框架，Spring帮助程序员来管理对象。
2. Spring的源码实现的是非常优秀的，设计模式的应用、并发安全的实现、面向接口的设计等。
3. 在创建Spring容器，也就是启动Spring时：
 1. 首先会进行扫描，扫描得到所有的BeanDefinition对象，并存在一个Map中。
 2. 然后筛选出非懒加载的单例BeanDefinition进行创建Bean，对于多例Bean不需要在启动过程中去进行创建，对于多例Bean会在每次获取Bean时利用BeanDefinition去创建。
 3. 利用BeanDefinition创建Bean就是Bean的创建生命周期，这期间包括了合并BeanDefinition、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP就是发生在初始化后这一步骤中。
4. 单例Bean创建完了之后，Spring会发布一个容器启动事件。
5. Spring启动结束。
6. 在源码中会更复杂，比如源码中会提供一些模板方法，让子类来实现，比如源码中还涉及到一些BeanFactoryPostProcessor和BeanPostProcessor的注册，Spring的扫描就是通过BenaFactoryPostProcessor来实现的，依赖注入就是通过BeanPostProcessor来实现的。
7. 在Spring启动过程中还会去处理＠lmport等注解。


#### 说一下Spring的事务机制
1. Spring事务底层是基于数据库事务和AOP机制的。
2. 首先对于使用了＠Transactional注解的Bean，Spring会创建一个代理对象作为Bean。
3. 当调用代理对象的方法时，会先判断该方法上是否加了＠Transactional注解。
4. 如果加了，那么则利用事务管理器创建一个数据库连接。
5. 并且修改数据库连接的autocommit属性为false，禁止此连接的自动提交，这是实现Spring事务非常重要的一步。
6. 然后执行当前方法，方法中会执行sql。
7. 执行完当前方法后，如果没有出现异常就直接提交事务。
8. 如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务。
9. Spring事务的隔离级别对应的就是数据库的隔离级别。
10. Spring事务的传播机制是Spring事务自己实现的，也是Spring事务中最复杂的。
11. Spring事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，如果传播机制配置为需要新开一个事务，那么实际上就是先建立一个数据库连接，在此新数据库连接上执行sql。


#### 什么时候＠Transactional失效
因为Spring事务是基于代理来实现的，所以某个加了＠Transactional的方法只有是被代理对象调用时，那么这个注解才会生效，所以如果是被代理对象来调用这个方法，那么＠Transactional是不会生效的。


同时如果某个方法是private的，那么＠Transactional也会失效，因为底层cglib是基于父子类来实现的，子类是不能重载父类的private方法的，所以无法很好的利用代理，也会导致＠Transactianal失效。


#### Dubbo是如何做系统交互的
Dubbo底层是通过RPC来完成服务和服务之间的调用的，Dubbo支持很多协议，比如默认的dubbo协议，比如http协议、比如rest等都是支持的，他们的底层所使用的技术是不太一样的，比如dubbo协议底层使用的是netty，也可以使用mina，http协议底层使用的tomcat或jetty。


服务消费者在调用某个服务时，会将当前所调用的服务接口信息、当前方法信息、执行方法所传入的入参信息等组装为一个Invocation对象，然后不同的协议通过不同的数据组织方式和传输方式将这个对象传送给服务提供者，提供者接收到这个对象后，找到对应的服务实现，利用反射执行对应的方法，得到方法结果后再通过网络响应给服务消费者。


当然，Dubbo在这个调用过程中还做很多其他的设计，比如服务容错、负载均衡、Filter机制、动态路由机制等等，让Dubbo能处理更多企业中的需求。


#### Dubbo的负载均衡策略
1. 平衡加权轮询算法
2. 加权随机算法
3. 一致性哈希算法
4. 最小活跃数算法


#### 还读过哪些框架源码介绍一下你还熟悉的
这个问题比较广泛，你即可以说：HashMap、线程池等JDK自带的源码，也可以说Mybatis、Spring Boot、Spring Cloud、消息队列等开发框架或中间件的源码。


#### Jdk1.7到Jdk1.8 HashMap发生了什么变化(底层)
1. 1.7中底层是数组+链表，1.8中底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询整体效率。
2. 1.7中链表插入使用的是头插法，1.8中链表插入使用的是尾插法，因为1.8中插入key和value时需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使用尾插法。
3. 1.7中哈希算法比较复杂，存在各种右移与异或运算，1.8中进行了简化，因为负载的哈希算法的目的就是提高散列性，来提供HashMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源。


#### Jdk1.7到Jdk1.8 java虚拟机发生了什么变化
1.7中存在永久代，1.8中没有永久代，替换它的是元空间，元空间所占的内存不是在虚拟机内部，而是本地内存空间，这么做的原因是，不管是永久代还是元空间，他们都是方法区的具体实现，之所以元空间所占的内存改成本地内存，官方的说法是为了和JRockit统一，不过额外还有一些原因，比如方法区所存储的类信息通常是比较难确定的，所以对于方法区的大小是比较难指定的，太小了容易出现方法区溢出，太大了又会占用了太多虚拟机的内存空间，而转移到本地内存后则不会影响虚拟机所占用的内存。




