## 题卷IV


### BIGO


#### 内存泄露怎么分析？怎么知道整条内存泄露的链路？
内存泄露或内存持续使用较高时，通常通过堆的情况来排查。首先可以通过`jmap -histo:live PID|less`命令查看堆内对象使用情况。此时如果内存泄露，一般都是会某个基本类型对象过多，然后可以与正常的服务作对比，看哪个对象的数量异常的多，此时如果可以判断出来，也没必要dump了。如果通过jmap无法断定，则可以使用`jmap -dump:live,format=b,file=`命令生成dump文件。将dump文件通过java原生的软件或者eclipse的mat工具，就可以看到哪些对象占用过多，此时你应该关注的是非基本类型对象的其他对象，因为一般来说都是基本类型的数量和大小最多。


一般来说，你会看到以下现象:


1. 某个map的Node十分多，有几十万个。
2. 某个框架的某个对象十分多。
3. char数据，也就是C[]，占用十分多，因为有很多大字符串。


#### 用的什么垃圾收集器？GC一次多久？线上多久一次Full GC？
G1


| GC类型 | 执行时间(建议值) | 执行频率(建议值) | 
| :----- | :----- | :----- | 
| Yong GC | <= 50ms | >= 10s/次 |
| Full GC | <= 1s | >= 10/min |


```
// 每秒一次, 连续输出10次 GC信息
jstat -gc PID 1000 10
```


```
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
 0.0   4096.0  0.0   4096.0 2637824.0 1824768.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 1837056.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 1853440.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 1902592.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 1910784.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 1957888.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 1968128.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 1974272.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 2023424.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 2033664.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
```


| 参数 | 解释 |
| :----- | :----- |
|S0C|第一个幸存区的大小|
|S1C|第二个幸存区的大小|
|S0U|第一个幸存区的使用大小|
|S1U|第二个幸存区的使用大小|
|EC|伊甸园区的大小|
|EU|伊甸园区的使用大小|
|OC|老年代大小|
|OU|老年代使用大小|
|MC|方法区大小|
|MU|方法区使用大小|
|CCSC|压缩类空间大小|
|CCSU|压缩类空间使用大小|
|YGC|年轻代垃圾回收次数|
|YGCT|年轻代垃圾回收消耗时间|
|FGC|老年代垃圾回收次数|
|FGCT|老年代垃圾回收消耗时间|
|GCT|垃圾回收消耗总时间|


PS: 之前的PC、PU被MC、MU取代了。(永久代)


#### 怎么进行JVM调优？何时需要做JVM调优？JVM调优量化目标？
** 怎么进行JVM调优 ** 


| 调优参数 | 解释 |
| :----- | :----- |
|<div style='width:100px'>-Xmx4g</div>|堆内存最大值为4GB。|
|<div style='width:100px'>-Xms4g</div>|初始化堆内存大小为4GB。|
|<div style='width:100px'>-Xss512k</div>|设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。|
|...|...|


**何时需要做JVM调优**


1. heap内存(老年代)持续上涨达到设置的最大内存值；
2. Full GC次数频繁；
3. GC停顿时间过长(超过1秒)；
4. 应用出现OutOfMemory等内存异常；
5. 应用中有使用本地缓存且占用大量内存空间；
6. 系统吞吐量与响应性能不高或下降。


**JVM调优量化目标**


1. Heap内存使用率 <= 70%；
2. Old generation内存使用率 <= 70%；
3. avg pause <= 1秒；
4. Full gc次数0 或 avg pause interval >= 24小时。


#### 项目里有用过ConcurrentHashMap吗？ConcurrentHashMap底层结构有了解吗？
**JDK1.7**


底层数据结构: `Segments数组 + HashEntry数组 + 链表`，采用分段锁保证安全性。


容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”分段锁”思想。


![](/images/ReviewIV/ConcurrentHashMap7.png)


1. 一个ConcurrentHashMap中有一个Segments数组，一个Segments中存储一个HashEntry数组，每个HashEntry是一个链表结构的元素。
2. segment继承自ReentrantLock锁。首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，实现了真正的并发访问。
3. 可以通过构造函数指定，数组扩容不会影响其他的segment，get无需加锁，volatile保证内存可见性。


| 操作 | 解释 |
| :----- | :----- |
|get()|HashEntry中的value属性和next指针是用volatile修饰的，保证了可见性，所以每次获取的都是最新值，get过程不需要加锁。<br>1. 将key传入get方法中，先根据key的hashcode的值找到对应的segment段。<br>2. 再根据segment中的get方法再次hash，找到HashEntry数组中的位置。<br>3. 最后在链表中根据hash值和equals方法进行查找。<br>ConcurrentHashMap的get操作跟HashMap类似，只是ConcurrentHashMap第一次需要经过一次hash定位到Segment的位置，然后再hash定位到指定的HashEntry，遍历该HashEntry下的链表进行对比，成功就返回，不成功就返回null。|
|put()|1. 将key传入put方法中，先根据key的hashcode的值找到对应的segment段。<br>2. 再根据segment中的put方法，加锁lock()。<br>3. 再次hash确定存放的hashEntry数组中的位置。<br>4. 在链表中根据hash值和equals方法进行比较，如果相同就直接覆盖，如果不同就插入在链表中。|


**JDK1.8**


底层数据结构: `Synchronized + CAS + Node + 红黑树`。Node的val和next都用volatile保证，保证可见性，查找、替换、赋值操作都使用CAS。


```
为什么在有Synchronized的情况下还要使用CAS？

因为CAS是乐观锁，在一些场景中(并发不激烈的情况下)它比Synchronized和ReentrentLock的效率要高，
当CAS保障不了线程安全的情况下(扩容或者hash冲突的情况下)转成Synchronized来保证线程安全，大大
提高了低并发下的性能。
```


锁是锁的链表的head的节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作(因为扩容的时候使用的是Synchronized锁，锁全表)，并发扩容。


读操作无锁，Node的val和next使用volatile修饰，读写线程对该变量互相可见；数组用volatile修饰，保证扩容时被读线程感知。


| 操作 | 解释 |
| :----- | :----- |
|get()|get操作全程无锁。get操作可以无锁是由于Node元素的val和指针next是用volatile修饰的。 在多线程环境下线程A修改节点的val或者新增节点的时候是对线程B可见的。<br>1. 计算hash值，定位到Node数组中的位置<br>2. 如果该位置为null，则直接返回null<br>3. 如果该位置不为null，再判断该节点是红黑树节点还是链表节点；如果是红黑树节点，使用红黑树的查找方式来进行查找；如果是链表节点，遍历链表进行查找|
|put()|1. 先判断Node数组有没有初始化，如果没有初始化先初始化initTable()。 <br>2. 根据key的进行hash操作，找到Node数组中的位置，如果不存在hash冲突，即该位置是null，直接用CAS插入。<br>3. 如果存在hash冲突，就先对链表的头节点或者红黑树的头节点加synchronized锁。<br>4. 如果是链表，就遍历链表，如果key相同就执行覆盖操作，如果不同就将元素插入到链表的尾部， 并且在链表长度大于8， Node数组的长度超过64时，会将链表的转化为红黑树。<br>5. 如果是红黑树，就按照红黑树的结构进行插入。|


👉 [ConcurrentHashMap底层结构和原理详解](https://blog.csdn.net/qq_45408390/article/details/122189726)


#### 你知道JDK7和JDK8之间的区别吗？
* 接口中的default方法


一般来说接口中的方法都是不实现的，基本通过实现类来实现方法。但是jdk8中提供了一种被default修饰的方法，可以直接在接口中进行实现。


* lambda表达式


jdk8引入了lambda表达式，也可称为closure(闭包)，通常是在需要一个函数，但又不想费神去命名一个函数的场合下使用，也就是指匿名函数。lambda允许把函数作为一个方法的参数(函数作为参数传递进方法中)。由于其几乎被所有主流开发语言支持。是java8新引入的一种语法，是一种紧凑的传递代码的方式。使用lambda表达式可以使代码变的更加简洁紧凑。


* 函数式接口


函数式接口的引入是为了函数式编程的，函数式编程往往依赖于lambda表达式。


定义函数式接口有两个步骤:
1. 确保接口中有且仅有一个抽象方法；
2. 使用注解@FunctionalInterface修饰接口。


* StreamAPI


JDK8中引入了StreamAPI，对于学过Flink或Spark的学者应该对此比较熟悉，其实就是类似于一种流式的数据处理，从dataSource到中间的operator操作，再到最后的dataSink。Stream的中间操作有map、filter等操作。而流式的数据处理往往就是通过函数式编程实现的。
![](/images/ReviewIV/Stream.png)


* 移出永久代，元空间替换


JDK7使用永久代存储类的元数据，JDK8使用元空间存储类的元数据。元空间和永久代都是用来存储class相关信息，包括class对象的Method，Field等，元空间和永久代其实都是方法区的实现，只是实现有所不同，所以说方法区其实只是一种JVM的规范。


两者最大的区别是元空间使用本地内存，而永久代使用的是JVM的内存。


元空间优势就是元数据分配只受本地内存大小的限制。本地内存剩余多少理论上metaspace就可以有多大，这解决了空间不足的问题，不过也不可能任其无限壮大，JVM默认在运行时会根据需要动态的设置其大小。


* HashMap中的优化


1. 增加红黑树
2. 解决jdk1.7多线程下的死循环。扩容使用尾插法，抛弃头插法。
3. rehash的优化。jdk7扩容的rehash是重新计算桶的位置，而jdk8则进行了优化，不需要进行重新计算。


* CurrentHashMap的优化


jdk7是使用分段锁实现线程安全，jdk8则使用synchronized关键字和大量的CAS操作实现。


#### 用过Stream吗，讲讲？
就根据平时使用说就好了，比较简单。


#### sql优化的经历？
1. 正确创建索引
2. 建表时合理选择数据类型
3. 不滥用事务
4. 使用定时作业去优化结构
5. 避免不必要的数据库连接
6. 学会使用sql分析工具(profiler)


👉 [sql数据库的优化](https://blog.csdn.net/qq_41510985/article/details/117778163)


#### 讲讲ES，ES文档数据太多了怎么办？
1. filesystem cache
2. 数据预热
3. 冷热分离
4. document模型设计
5. 分页性能优化
    1. 不允许深度分页/默认深度分页性能很惨
    2. 类似于app里的推荐商品不断下拉出来一页一页的
    
    
👉 [ES在数据量很大的情况下如何提高查询效率？](https://blog.csdn.net/lukabruce/article/details/123520323)


#### RocketMQ集群的原理，消息堆积怎么办，推拉模式优劣？
| 模式 | 优点 | 缺点 |
| :----- | :----- | :----- |
|推模式|1. 实时性强，有消息立马推送给客户端。<br>2. 客户端实现简单，只需要监听服务端的推送即可。|1. 容易导致客户端发生消息堆积的情况，因为每个客户端的消费能力是不同的，如果简单粗暴的有消息就推送，就会会出现堆积情况。<br>2. 服务端逻辑复杂，因为简单的推送会导致客户端出现堆积问题，所以服务端需要进行优化。记录给每个客户端的推送数据，然后根据每个客户端的消费能力去平衡数据推送的速度。|
|拉模式|1. 不会造成客户端消息积压，消费完了再去拉取，主动权在自己手中。<br>2. 长轮询实现的拉模式实时性也能够保证。|1. 客户端的逻辑实现相对复杂点，简化了服务端的逻辑。<br>|


👉 [消息队列，推拉模式的区别在哪？](https://blog.csdn.net/jiagoubaiduren/article/details/124829036)


#### 说下Raft协议？
Raft是一种实现分布式共识(一致性)的协议，也就是多个节点达成一致的协议。Raft算法想解决的核心问题是分布式共识问题。


分布式存储系统的核心问题之一: 维护多个副本的数据一致性。


Raft将一致性算法分为了几个部分，包括：领导选取(leader selection)、日志复制(log replication)、安全性(safety)、成员变更。


👉 [Raft协议简介](https://blog.csdn.net/chongbin007/article/details/117330501)


#### 分布式ID的设计方案？
1. 使用UUID生成ID
2. 使用数据库单机自增生成
3. 使用数据库集群模式自增生成
4. 使用数据库号段模式自增生成
5. 使用Redis单节点实现分布式ID
6. 使用Redis集群实现分布式
7. 利用Snowflake算法实现ID
8. 使用Zookeeper生成ID
9. 使用MongoDB创建ObjectID


👉 [Java中分布式ID的设计方案](https://baijiahao.baidu.com/s?id=1725596058860143229&wfr=spider&for=pc)


#### Redis集群的特性，分布式锁的设计？
1. Redis主从同步
2. 哨兵模式
3. cluster集群模式


👉 [redis集群、分布式锁](https://blog.csdn.net/weixin_35821291/article/details/123112125)


### 腾讯


#### HTTP/HTTPS，网络安全问题？
👉 [HTTPS如何解决HTTP存在的安全性问题](https://blog.csdn.net/qq_44159028/article/details/121060709)


#### volatile和synchronized的区别？
一旦一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰之后，那么就具备了两层语义:


1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2. 禁止进行指令重排序。


| 参数 | 区别 |
| :----- | :----- |
|volatile|1. 本质是在告诉jvm当前变量在寄存器(工作内存)中的值是不确定的，需要从主存中读取。<br>2. 仅能使用在变量级别。<br>3. 仅能实现变量的修改可见性，并不能保证原子性。<br>4. 不会造成线程的阻塞。<br>5. 标记的变量不会被编译器优化。|
|synchronized|1. 锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞。<br>2. 可以使用在变量、方法、类级别的。<br>3. 可以保证变量的修改可见性和原子性。<br>4. 可能会造成线程的阻塞。<br>5. 标记的变量可以被编译器优化。|


👉 [synchronized和volatile的区别](https://www.cnblogs.com/gaokeji/p/16058072.html)


#### JAVA内存模型？
JVM中试图定义一种JMM来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。


![](/images/ReviewIV/JMM.png)


JMM定义了8个操作来完成主内存和工作内存之间的交互操作。JVM实现时必须保证下面介绍的每种操作都是原子的(对于double和long型的变量来说，load、store、read和write操作在某些平台上允许有例外)。


| 操作 | 解释 |
| :----- | :----- |
|lock(锁定)|作用于主内存的变量，它把一个变量标识为一条线程独占的状态。|
|unlock(解锁)|作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。|
|read(读取)|作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。|
|write(写入)|作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。|
|load(载入)|作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。|
|use(使用)|作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时就会执行这个操作。|
|assign(赋值)|作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。|
|store(存储)|作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后write操作使用。|


如果要把一个变量从主内存中复制到工作内存，就需要按序执行read和load操作；如果把变量从工作内存中同步回主内存中，就需要按序执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。


JMM还规定了上述8种基本操作，需要满足以下规则:


1. read和load必须成对出现；store和write必须成对出现。即不允许一个变量从主内存读取了但工作内存不接受，或从工作内存发起回写了但主内存不接受的情况出现。
2. 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须把变化同步到主内存中。
3. 不允许一个线程无原因的(没有发生过任何assign操作)把数据从工作内存同步回主内存中。
4. 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量。换句话说，就是对一个变量实施use和store操作之前，必须先执行过了load或assign操作。
5. 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。所以lock和unlock必须成对出现。
6. 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
7. 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。
8. 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中(执行store和write操作)。


👉 [Java 内存模型](https://blog.csdn.net/m0_50414588/article/details/123912057)


#### Redis实现分布式锁与Zookeeper实现分布式锁的异同点？
| Redis | Zookeeper |
| :----- | :----- |
|1. 多个客户端(JVM)，会在Redis使用setnx命令创建相同的一个key，因为Redis的key保证唯一，不允许出现重复，只要谁能够先创建成功，谁能够获取到锁。<br>2. 在释放锁的时候，为了确保是锁的一致性问题，在删除的redis的key时候，需要判断同一个锁的id，才可以删除。<br>3. 对key设置有效期解决死锁现象。|1. 多个客户端(JVM)，会在Zookeeper上创建同一个临时节点，因为Zookeeper节点命名路径保证唯一，不允许出现重复，只要谁能够先创建成功，谁能够获取到锁。<br>2. 使用直接关闭临时节点session会话连接，因为临时节点生命周期与session会话绑定在一块，如果session会话连接关闭的话，该临时节点也会被删除。这时候客户端使用事件监听，如果该临时节点被删除的话，重新进入盗获取锁的步骤。<br>3. 使用会话有效期方式解决死锁现象。|


#### Innodb讲讲？
把知道的都说出来就好了。行锁、MVCC、外键、一致性读......


#### ZAB讲讲？
1. ZAB协议全称: Zookeeper Atomic Broadcast(Zookeeper原子广播协议)。
2. Zookeeper是一个为分布式应用提供高效且可靠的分布式协调服务。在解决分布式一致性方面，Zookeeper并没有使用Paxos，而是采用了ZAB协议。
3. ZAB协议定义: ZAB协议是为分布式协调服务。Zookeeper专门设计的一种支持崩溃恢复和原子广播协议。
4. 基于该协议，Zookeeper实现了一种主备模式的系统架构来保持集群中各个副本之间数据一致性。


ZAB协议和我们之前看的Raft协议实际上是有相似之处的，比如都有一个Leader，用来保证一致性(Paxos并没有使用Leader机制保证一致性)。再有采取过半即成功的机制保证服务可用(实际上Paxos和Raft都是这么做的)。ZAB让整个Zookeeper集群在两个模式之间转换，消息广播和崩溃恢复，消息广播可以说是一个简化版本的2PC，通过崩溃恢复解决了2PC的单点问题，通过队列解决了2PC的同步阻塞问题。而支持崩溃恢复后数据准确性的就是数据同步了，数据同步基于事务的ZXID的唯一性来保证。通过+1操作可以辨别事务的先后顺序。


👉 [ZAB算法详解](https://blog.csdn.net/yizhiniu_xuyw/article/details/114870828)


#### 怎么分库分表？
如果一个网站业务快速发展，那这个网站流量也会增加，数据的压力也会随之而来，比如电商系统来说双十一大促对订单数据压力很大，TPS十几万并发量，如果传统的架构(一主多从)，主库容量肯定无法满足这么高的TPS，业务越来越大，单表数据超出了数据库支持的容量，持久化磁盘IO，传统的数据库性能瓶颈，产品经理业务必须做，改变程序，数据库刀子切分优化。数据库连接数不够需要分库，表的数据量大，优化后查询性能还是很低，需要分。


👉 [MySQL数据库之分库分表方案](https://blog.csdn.net/weixin_46217160/article/details/120464899)


#### 怎么自己实现IOC？


#### 用过哪些设计模式，讲讲？


#### 怎么判断一个链表是不是有环？


#### 自我介绍？


#### ES讲了个遍，包括基础原理和优化？


#### 分布式ID的生成方式？


#### 布式事务相关知识，保证数据一致性？


#### 为什么要用框架做分布式，没有行不行？


### 快手


#### 数据库连接不上了，怎么排查？


#### 双亲委派模型，有什么好处？


#### ThreadLocal讲讲？


#### 一次接口调用，在日志文件里打印”kuaishou ”+耗时，比如“kuaishou 20ms”,"kuaishou 50ms","kuaishou 100ms"，有十万条，用linux的命令怎么查出来耗时最短的十条？


#### 安装了一个软件，怎么在linux找到他的路径？


#### 怎么查看jvm里线程状态？


#### CountDownLatch和CyclicBarrier有什么区别？


#### jps -m，jps -l用过吗？


#### 讲一下Spring事务底层是怎么实现的？


### 菜⻦&嘀嘀


#### JVM内存溢出排查？


#### 网络编程相关的提问


#### 并发包相关问题


#### 线程池原理


#### mysql索引，锁机制，隔离级别


#### Redis连环炮


#### Tomcat起两个war包，怎么识别哪个请求要给到哪个进程？


#### linux的命令，比如怎么查看给文件按大小排序，主要是查看日志相关的技巧命令？


#### volatile内存屏障具体是怎么实现？


#### JVM启动参数有哪些？怎么调优？TLAB是什么？阻塞队列对比和选择？


#### DDD的理解？


#### Reactor模型？


### 蚂蚁金服


#### CHM结构，线程安全保证，加锁实现细节？


#### JVM内存结构，垃圾回收原理，GC配合策略，排查过程细节和调优方案？


#### 线程安全的本质？


#### 并发锁，AQS原理


#### ThreadLocal源码


#### mysql幻读，怎么加锁


#### 秒杀设计


### 淘宝


#### 网络模型，NIO，Netty


#### JVM，垃圾回收，调优，排查思路


#### Redis为什么快？使用场景？过期策略？


#### RocketMQ场景，如何保证不丢消息？


#### Spring Bean生命周期


#### 线程池参数，执行顺序，场景？


#### Mysql 存储引擎，索引？


### 饿了么


#### CHM和HashTable


#### JVM垃圾回收的原理，GC排查步骤


#### volatile，synchronized


#### SQL优化，事务隔离级别


#### MQ的区别以及选型


#### Redis分布式锁


#### 业务幂等实现


#### 分库分表，MyCat底层实现原理


#### 监控指标，业务分析，业务指标


#### 亮点业务，好的项目


