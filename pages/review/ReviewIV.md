## 题卷IV


### BIGO


#### 内存泄露怎么分析？怎么知道整条内存泄露的链路？
内存泄露或内存持续使用较高时，通常通过堆的情况来排查。首先可以通过`jmap -histo:live PID|less`命令查看堆内对象使用情况。此时如果内存泄露，一般都是会某个基本类型对象过多，然后可以与正常的服务作对比，看哪个对象的数量异常的多，此时如果可以判断出来，也没必要dump了。如果通过jmap无法断定，则可以使用`jmap -dump:live,format=b,file=`命令生成dump文件。将dump文件通过java原生的软件或者eclipse的mat工具，就可以看到哪些对象占用过多，此时你应该关注的是非基本类型对象的其他对象，因为一般来说都是基本类型的数量和大小最多。


一般来说，你会看到以下现象:


1. 某个map的Node十分多，有几十万个。
2. 某个框架的某个对象十分多。
3. char数据，也就是C[]，占用十分多，因为有很多大字符串。


#### 用的什么垃圾收集器？GC一次多久？线上多久一次Full GC？
G1


| GC类型 | 执行时间(建议值) | 执行频率(建议值) | 
| :----- | :----- | :----- | 
| Yong GC | <= 50ms | >= 10s/次 |
| Full GC | <= 1s | >= 10/min |


```
// 每秒一次, 连续输出10次 GC信息
jstat -gc PID 1000 10
```


```
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
 0.0   4096.0  0.0   4096.0 2637824.0 1824768.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 1837056.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 1853440.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 1902592.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 1910784.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 1957888.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 1968128.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 1974272.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 2023424.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
 0.0   4096.0  0.0   4096.0 2637824.0 2033664.0 1552384.0   316716.7  216248.0 193369.5 25600.0 22631.0    162    2.778   0      0.000    2.778
```


| 参数 | 解释 |
| :----- | :----- |
|S0C|第一个幸存区的大小|
|S1C|第二个幸存区的大小|
|S0U|第一个幸存区的使用大小|
|S1U|第二个幸存区的使用大小|
|EC|伊甸园区的大小|
|EU|伊甸园区的使用大小|
|OC|老年代大小|
|OU|老年代使用大小|
|MC|方法区大小|
|MU|方法区使用大小|
|CCSC|压缩类空间大小|
|CCSU|压缩类空间使用大小|
|YGC|年轻代垃圾回收次数|
|YGCT|年轻代垃圾回收消耗时间|
|FGC|老年代垃圾回收次数|
|FGCT|老年代垃圾回收消耗时间|
|GCT|垃圾回收消耗总时间|


PS: 之前的PC、PU被MC、MU取代了。(永久代)


#### 怎么进行JVM调优？何时需要做JVM调优？JVM调优量化目标？
** 怎么进行JVM调优 ** 


| 调优参数 | 解释 |
| :----- | :----- |
|<div style='width:100px'>-Xmx4g</div>|堆内存最大值为4GB。|
|<div style='width:100px'>-Xms4g</div>|初始化堆内存大小为4GB。|
|<div style='width:100px'>-Xss512k</div>|设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。|
|...|...|


**何时需要做JVM调优**


1. heap内存(老年代)持续上涨达到设置的最大内存值；
2. Full GC次数频繁；
3. GC停顿时间过长(超过1秒)；
4. 应用出现OutOfMemory等内存异常；
5. 应用中有使用本地缓存且占用大量内存空间；
6. 系统吞吐量与响应性能不高或下降。


**JVM调优量化目标**


1. Heap内存使用率 <= 70%；
2. Old generation内存使用率 <= 70%；
3. avg pause <= 1秒；
4. Full gc次数0 或 avg pause interval >= 24小时。


#### 项目里有用过ConcurrentHashMap吗？ConcurrentHashMap底层结构有了解吗？
**JDK1.7**


底层数据结构: `Segments数组 + HashEntry数组 + 链表`，采用分段锁保证安全性。


容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”分段锁”思想。


![](/images/ReviewIV/ConcurrentHashMap7.png)


1. 一个ConcurrentHashMap中有一个Segments数组，一个Segments中存储一个HashEntry数组，每个HashEntry是一个链表结构的元素。
2. segment继承自ReentrantLock锁。首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，实现了真正的并发访问。
3. 可以通过构造函数指定，数组扩容不会影响其他的segment，get无需加锁，volatile保证内存可见性。


| 操作 | 解释 |
| :----- | :----- |
|get()|HashEntry中的value属性和next指针是用volatile修饰的，保证了可见性，所以每次获取的都是最新值，get过程不需要加锁。<br>1. 将key传入get方法中，先根据key的hashcode的值找到对应的segment段。<br>2. 再根据segment中的get方法再次hash，找到HashEntry数组中的位置。<br>3. 最后在链表中根据hash值和equals方法进行查找。<br>ConcurrentHashMap的get操作跟HashMap类似，只是ConcurrentHashMap第一次需要经过一次hash定位到Segment的位置，然后再hash定位到指定的HashEntry，遍历该HashEntry下的链表进行对比，成功就返回，不成功就返回null。|
|put()|1. 将key传入put方法中，先根据key的hashcode的值找到对应的segment段。<br>2. 再根据segment中的put方法，加锁lock()。<br>3. 再次hash确定存放的hashEntry数组中的位置。<br>4. 在链表中根据hash值和equals方法进行比较，如果相同就直接覆盖，如果不同就插入在链表中。|


**JDK1.8**


底层数据结构: `Synchronized + CAS + Node + 红黑树`。Node的val和next都用volatile保证，保证可见性，查找、替换、赋值操作都使用CAS。


```
为什么在有Synchronized的情况下还要使用CAS？

因为CAS是乐观锁，在一些场景中(并发不激烈的情况下)它比Synchronized和ReentrentLock的效率要高，
当CAS保障不了线程安全的情况下(扩容或者hash冲突的情况下)转成Synchronized来保证线程安全，大大
提高了低并发下的性能。
```


锁是锁的链表的head的节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作(因为扩容的时候使用的是Synchronized锁，锁全表)，并发扩容。


读操作无锁，Node的val和next使用volatile修饰，读写线程对该变量互相可见；数组用volatile修饰，保证扩容时被读线程感知。


| 操作 | 解释 |
| :----- | :----- |
|get()|get操作全程无锁。get操作可以无锁是由于Node元素的val和指针next是用volatile修饰的。 在多线程环境下线程A修改节点的val或者新增节点的时候是对线程B可见的。<br>1. 计算hash值，定位到Node数组中的位置<br>2. 如果该位置为null，则直接返回null<br>3. 如果该位置不为null，再判断该节点是红黑树节点还是链表节点；如果是红黑树节点，使用红黑树的查找方式来进行查找；如果是链表节点，遍历链表进行查找|
|put()|1. 先判断Node数组有没有初始化，如果没有初始化先初始化initTable()。 <br>2. 根据key的进行hash操作，找到Node数组中的位置，如果不存在hash冲突，即该位置是null，直接用CAS插入。<br>3. 如果存在hash冲突，就先对链表的头节点或者红黑树的头节点加synchronized锁。<br>4. 如果是链表，就遍历链表，如果key相同就执行覆盖操作，如果不同就将元素插入到链表的尾部， 并且在链表长度大于8， Node数组的长度超过64时，会将链表的转化为红黑树。<br>5. 如果是红黑树，就按照红黑树的结构进行插入。|


👉 [ConcurrentHashMap底层结构和原理详解](https://blog.csdn.net/qq_45408390/article/details/122189726)


#### 你知道JDK7和JDK8之间的区别吗？
* 接口中的default方法


一般来说接口中的方法都是不实现的，基本通过实现类来实现方法。但是jdk8中提供了一种被default修饰的方法，可以直接在接口中进行实现。


* lambda表达式


jdk8引入了lambda表达式，也可称为closure(闭包)，通常是在需要一个函数，但又不想费神去命名一个函数的场合下使用，也就是指匿名函数。lambda允许把函数作为一个方法的参数(函数作为参数传递进方法中)。由于其几乎被所有主流开发语言支持。是java8新引入的一种语法，是一种紧凑的传递代码的方式。使用lambda表达式可以使代码变的更加简洁紧凑。


* 函数式接口


函数式接口的引入是为了函数式编程的，函数式编程往往依赖于lambda表达式。


定义函数式接口有两个步骤:
1. 确保接口中有且仅有一个抽象方法；
2. 使用注解@FunctionalInterface修饰接口。


* StreamAPI


JDK8中引入了StreamAPI，对于学过Flink或Spark的学者应该对此比较熟悉，其实就是类似于一种流式的数据处理，从dataSource到中间的operator操作，再到最后的dataSink。Stream的中间操作有map，filter等操作。而流式的数据处理往往就是通过函数式编程实现的。
![](/images/ReviewIV/Stream.png)


* 移出永久代，元空间替换


JDK7使用永久代存储类的元数据，JDK8使用元空间存储类的元数据。元空间和永久代都是用来存储class相关信息，包括class对象的Method，Field等，元空间和永久代其实都是方法区的实现，只是实现有所不同，所以说方法区其实只是一种JVM的规范。


两者最大的区别是元空间使用本地内存，而永久代使用的是JVM的内存。


元空间优势就是元数据分配只受本地内存大小的限制。本地内存剩余多少理论上metaspace就可以有多大，这解决了空间不足的问题，不过也不可能任其无限壮大，JVM默认在运行时会根据需要动态的设置其大小。


* HashMap中的优化


1. 增加红黑树
2. 解决jdk1.7多线程下的死循环。扩容使用尾插法，抛弃头插法。
3. rehash的优化。jdk7扩容的rehash是重新计算桶的位置，而jdk8则进行了优化，不需要进行重新计算。


* CurrentHashMap的优化


jdk7是使用分段锁实现线程安全，jdk8则使用synchronized关键字和大量的CAS操作实现。


#### 用过Stream吗，讲讲？


#### sql优化的经历？


#### 讲讲ES，ES文档数据太多了怎么办？


#### RocketMQ集群的原理，消息堆积怎么办，推拉模式优劣？


#### 说下Raft协议？


#### 分布式ID的设计方案？


#### Redis集群的特性，分布式锁的设计？


### 腾讯


#### HTTP/HTTPS，网络安全问题？、


#### volatile和synchronized的区别？


#### JAVA内存模型？


#### Redis分布式锁？


#### Innodb讲讲？


#### ZAB讲讲？


#### 怎么分库分表？


#### 怎么自己实现IOC？


#### 用过哪些设计模式，讲讲？


#### 怎么判断一个链表是不是有环？


#### 自我介绍？


#### ES讲了个遍，包括基础原理和优化？


#### 分布式ID的生成方式？


#### 布式事务相关知识，保证数据一致性？


#### 为什么要用框架做分布式，没有行不行？


### 快手


#### 数据库连接不上了，怎么排查？


#### 双亲委派模型，有什么好处？


#### ThreadLocal讲讲？


#### 一次接口调用，在日志文件里打印”kuaishou ”+耗时，比如“kuaishou 20ms”,"kuaishou 50ms","kuaishou 100ms"，有十万条，用linux的命令怎么查出来耗时最短的十条？


#### 安装了一个软件，怎么在linux找到他的路径？


#### 怎么查看jvm里线程状态？


#### CountDownLatch和CyclicBarrier有什么区别？


#### jps -m，jps -l用过吗？


#### 讲一下Spring事务底层是怎么实现的？


### 菜⻦&嘀嘀


#### JVM内存溢出排查？


#### 网络编程相关的提问


#### 并发包相关问题


#### 线程池原理


#### mysql索引，锁机制，隔离级别


#### Redis连环炮


#### Tomcat起两个war包，怎么识别哪个请求要给到哪个进程？


#### linux的命令，比如怎么查看给文件按大小排序，主要是查看日志相关的技巧命令？


#### volatile内存屏障具体是怎么实现？


#### JVM启动参数有哪些？怎么调优？TLAB是什么？阻塞队列对比和选择？


#### DDD的理解？


#### Reactor模型？


### 蚂蚁金服


#### CHM结构，线程安全保证，加锁实现细节？


#### JVM内存结构，垃圾回收原理，GC配合策略，排查过程细节和调优方案？


#### 线程安全的本质？


#### 并发锁，AQS原理


#### ThreadLocal源码


#### mysql幻读，怎么加锁


#### 秒杀设计


### 淘宝


#### 网络模型，NIO，Netty


#### JVM，垃圾回收，调优，排查思路


#### Redis为什么快？使用场景？过期策略？


#### RocketMQ场景，如何保证不丢消息？


#### Spring Bean生命周期


#### 线程池参数，执行顺序，场景？


#### Mysql 存储引擎，索引？


### 饿了么


#### CHM和HashTable


#### JVM垃圾回收的原理，GC排查步骤


#### volatile，synchronized


#### SQL优化，事务隔离级别


#### MQ的区别以及选型


#### Redis分布式锁


#### 业务幂等实现


#### 分库分表，MyCat底层实现原理


#### 监控指标，业务分析，业务指标


#### 亮点业务，好的项目


