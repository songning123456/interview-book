#### HTTP支持的请求方法？响应状态返回值的含义？
| 方法 | 解释 | 
| :----- | :----- | 
| OPTIONS | 返回服务器针对特定资源所支持的HTTP请求方法 | 
| HEAD | 与GET请求一致，只不过不会返回响应体 | 
| GET | 请求指定的资源 | 
| POST | 向指定资源提交数据进行处理请求，数据包含在请求体中，可能会导致新资源的创建或已有资源的修改 | 
| PUT | 向指定资源位置上传最新内容 | 
| DELETE | 请求服务器删除所标识的资源 | 


<table>
    <tr>
        <td rowspan="2">1xx</td>
        <td rowspan="2" style="width: 200px">该类型状态码表示接收到请求并且继续处理</td>
        <td>100</td>
        <td>客户端必须继续发出请求</td>
    </tr>
    <tr>
        <td>101</td>
        <td>客户端要求服务器根据请求转换HTTP协议版本</td>
    </tr>
    <tr>
        <td rowspan="7">2xx</td>
        <td rowspan="7" style="width: 200px">该类型状态码表示动作被成功接收、理解和接受</td>
        <td>200</td>
        <td>表明该请求被成功地完成，所请求的资源发送到客户端</td>
    </tr>
    <tr>
        <td>201</td>
        <td>提示知道新文件的URL</td>
    </tr>
    <tr>
        <td>202</td>
        <td>接受并处理，但处理未完成</td>
    </tr>
    <tr>
        <td>203</td>
        <td>返回信息不确定或不完整</td>
    </tr>
    <tr>
        <td>204</td>
        <td>收到请求，但返回信息为空</td>
    </tr>
    <tr>
        <td>205</td>
        <td>服务器完成了请求，用户必须复位当前已经浏览过的文件</td>
    </tr>
    <tr>
        <td>206</td>
        <td>服务器已经完成了部分用户的GET请求</td>
    </tr>
    <tr>
        <td rowspan="8">3xx</td>
        <td rowspan="8" style="width: 200px">该类型状态码表示为了完成指定的动作，必须接受进一步处理</td>
        <td>300</td>
        <td>请求的资源可在多处获得</td>
    </tr>
    <tr>
        <td>301</td>
        <td>本网页被永久性转移到另一个URL</td>
    </tr>
    <tr>
        <td>302</td>
        <td>请求的网页被重定向到新的地址</td>
    </tr>
    <tr>
        <td>303</td>
        <td>建议用户访问其他URL或访问方式</td>
    </tr>
    <tr>
        <td>304</td>
        <td>自从上次请求后，请求的网页未修改过</td>
    </tr>
    <tr>
        <td>305</td>
        <td>请求的资源必须从服务器指定的地址获得</td>
    </tr>
    <tr>
        <td>306</td>
        <td>前一版本HTTP中使用的代码，现已不再使用</td>
    </tr>
    <tr>
        <td>307</td>
        <td>声明请求的资源临时性删除</td>
    </tr>
    <tr>
        <td rowspan="18">4xx</td>
        <td rowspan="18" style="width: 200px">该类型状态码表示请求包含错误语法或不能正确执行</td>
        <td>400</td>
        <td>客户端请求有语法错误</td>
    </tr>
    <tr>
        <td>401</td>
        <td>请求未经授权</td>
    </tr>
    <tr>
        <td>402</td>
        <td>保留有效ChargeTo头响应</td>
    </tr>
    <tr>
        <td>403</td>
        <td>禁止访问，服务器收到请求，但拒绝提供服务</td>
    </tr>
    <tr>
        <td>404</td>
        <td>可连接服务器，但服务器无法取得所请求的网页，请求资源不存在</td>
    </tr>
    <tr>
        <td>405</td>
        <td>用户在Request-Line字段定义的方法不被允许</td>
    </tr>
    <tr>
        <td>406</td>
        <td>根据用户发送的Accept，请求资源不可访问</td>
    </tr>
    <tr>
        <td>407</td>
        <td>类似401，用户必须首先在代理服务器上取得授权</td>
    </tr>
    <tr>
        <td>408</td>
        <td>客户端没有在用户指定的时间内完成请求</td>
    </tr>
    <tr>
        <td>409</td>
        <td>对当前资源状态，请求不能完成</td>
    </tr>
    <tr>
        <td>410</td>
        <td>服务器上不再有此资源</td>
    </tr>
    <tr>
        <td>411</td>
        <td>服务器拒绝用户定义的Content-Length属性请求</td>
    </tr>
    <tr>
        <td>412</td>
        <td>一个或多个请求头字段在当前请求中错误</td>
    </tr>
    <tr>
        <td>413</td>
        <td>请求的资源大于服务器允许的大小</td>
    </tr>
    <tr>
        <td>414</td>
        <td>请求的资源URL长于服务器允许的长度</td>
    </tr>
    <tr>
        <td>415</td>
        <td>请求资源不支持请求项目格式</td>
    </tr>
    <tr>
        <td>416</td>
        <td>请求中包含Range请求头字段，在当前请求资源范围内没有range指示值</td>
    </tr>
    <tr>
        <td>417</td>
        <td>服务器不满足请求Expect头字段指定的期望值</td>
    </tr>
    <tr>
        <td rowspan="6">5xx</td>
        <td rowspan="6" style="width: 200px">该类型状态码表示服务器或网关错误</td>
        <td>500</td>
        <td>服务器错误</td>
    </tr>
    <tr>
        <td>501</td>
        <td>服务器不支持请求的功能</td>
    </tr>
    <tr>
        <td>502</td>
        <td>网关错误</td>
    </tr>
    <tr>
        <td>503</td>
        <td>无法获得服务</td>
    </tr>
    <tr>
        <td>504</td>
        <td>网关超时</td>
    </tr>
    <tr>
        <td>505</td>
        <td>不支持的http版本</td>
    </tr>
</table>


#### HTTP响应的结构是怎么样的？
| 组成部分 | 解释 | 
| :----- | :----- | 
| <div style="width: 200px">状态码(Status Code)</div> | 描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC_OK | 
| <div style="width: 200px">HTTP头部(HTTP Header)</div> | 它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在Serlet中检索HTTP的头部看这里 | 
| <div style="width: 200px">主体(Body)</div> | 它包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的 | 


#### 什么是HTTP隧道？
HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。


#### HTTP和TCP的区别？
TCP是底层通讯协议，定义的是数据传输和连接方式的规范；HTTP是应用层协议，定义的是传输数据的内容的规范。


HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP。


HTTP支持的是www服务，而TCP/IP是协议，它是Internet国际互联网络的基础。


TCP/IP是网络中使用的基本的通信协议。它包括上百个各种功能的协议，如：远程登录、文件传输和电子邮件等，而TCP协议和IP协议是保证数据完整传输的两个基本的重要协议。通常说TCP/IP是Internet协议族，而不单单是TCP和IP。


#### 什么是cookie？session和cookie有什么区别？
cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。


| session | cookie | 
| :----- | :----- | 
| <div style="width: 250px">基于服务器生成</div> | 基于浏览器生成 | 
| <div style="width: 250px">数据保存在服务器端</div> | 数据保存在客户端 | 
| <div style="width: 250px">相对更安全</div> | 相对不安全 | 
| <div style="width: 250px">过期时间是相对的</div> | 过期时间是绝对的 | 
| <div style="width: 250px">客户端无法禁用服务端的session，无论客户端浏览器做怎么样的设置，session都应该能正常工作</div> | 客户端可以选择禁用cookie | 
| <div style="width: 250px">能够存储任意的Java对象</div> | 只能存储String类型的对象 | 


#### GET提交方式与POST提交方式的区别？
| GET | POST | 
| :----- | :----- | 
| 在浏览器回退时是无害的 | 再次请求 | 
| URL地址可以被收藏 | 不会 | 
| 被浏览器主动缓存 | 不会，除非手动设置 | 
| 只能进行URL编程 | 支持多种编码方式 | 
| 请求参数会被完整保留在浏览器历史里 | 参数不会被保留 | 
| 在URL中传送的参数有长度限制，不能大于2KB | 参数没有长度限制 | 
| 只接受ascll字符 | 没有限制 | 
| 参数直接暴露在URL上，所以不能用来传递敏感信息 | 安全 | 
| 通过URL传递 | 放在request body中 | 
| 不支持 | 进行文件上传 | 


#### 什么是URL编码和URL解码？
URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。


#### 客户端传输的数据如何保证安全性？
| 方式 | 解释 | 特点 | 局限性 | 算法 | 
| :----- | :----- | :----- | :----- | :----- | 
| <div style="width: 120px">对称加密</div> | 加密和解密使用同一个密钥 | 保证了数据的保密性 | 无法解决密钥交换问题 | DES、3DES、AES | 
| <div style="width: 120px">公钥加密</div> | 生成一个密钥对，加密使用私钥加密，解密使用公钥解密 | 解决了密钥交换问题 | 对大的数据加密速度慢 | ———— | 
| <div style="width: 120px">单向加密</div> | 提取数据的特征码 | 定长输出，不可逆，可检验数据的完整性 | 无法保证数据的保密性 | MD5、SHA1、CRC-32 | 


#### HTTPS的工作原理？为啥用HTTPS就可以加密通信？
浏览器把自己支持的加密规则发送给网站。


网站从这套加密规则里选出来一套加密算法和hash算法，然后把自己的身份信息用证书的方式发回给浏览器，证书里有网站地址、加密公钥、证书颁发机构。


浏览器验证证书的合法性，然后浏览器地址栏上会出现一把小锁；浏览器接着生成一串随机数密码，然后用证书里的公钥进行加密，这块走的是非对称加密；用约定好的hash算法生成握手消息的hash值，然后用密码对消息进行加密，然后把所有东西都发给网站，这块走的是对称加密。


网站从消息里面可以取出来公钥加密后的随机密码，用本地的私钥对消息解密取出来密码，然后用密码解密浏览器发来的握手消息，计算消息的hash值，并验证与浏览器发送过来的hash值是否一致，最后用密码加密一段握手消息，发给浏览器。


浏览器解密握手消息，然后生成的随机密码，然后用对称加密来进行进行加密。(常用的非对称加密是RSA算法，对称加密是AES、RC4等，hash算法就是MD5。)计算消息的hash值，如果跟网站发来的hash一样，握手就结束，之后所有的数据都会由之前浏览器。


#### 说说你们项目如何实现跨域名访问的？
使用了CORS跨域解决方案。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。


#### <a href="https://blog.csdn.net/lzuacm/article/details/50945225">TCP和UDP的区别？</a>
| TCP | UDP | 
| :----- | :----- | 
| 面向连接 | 无连接 | 
| 可靠 | 不可靠 | 
| 有序 | 不提供序列性保证 | 
| 不保存数据的边界 | 保存数据的边界 | 
| 速度比较慢 | 速度比较快 | 
| 重量级 | 轻量级 | 
| 数据包报头的大小是20字节 | 数据包报头是8个字节 | 
| 流量控制 | 不能进行流量控制 | 
| 金融领域 | 游戏和娱乐场所 | 


#### <a href="https://blog.csdn.net/huwei2003/article/details/45476743">DDos攻击及预防？</a>
确保服务器的系统文件是最新的版本，并及时更新系统补丁。


关闭不必要的服务。


限制同时打开的SYN半连接数目，缩短SYN半连接的time out时间，限制SYN/ICMP流量。


正确设置防火墙。


认真检查网络设备和主机/服务器系统的日志。只要日志出现漏洞或是时间变更，那这台机器就可能遭到了攻击。


限制在防火墙外与网络文件共享。这样会给黑客截取系统文件的机会，主机的信息暴露给黑客，无疑是给了对方入侵的机会。


充分利用网络设备保护网络资源。


用足够的机器承受黑客攻击。


检查访问者的来源。