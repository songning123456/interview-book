{"./":{"url":"./","title":"interview of sonin","keywords":"","body":"简介 "},"pages/分布式/你们的系统使用了哪种服务框架为什么要这样技术选型.html":{"url":"pages/分布式/你们的系统使用了哪种服务框架为什么要这样技术选型.html","title":"你们的系统使用了哪种服务框架?为什么要这样技术选型?","keywords":"","body":" Spring Cloud & Dubbo对比 (1) 并发性能 Spring Cloud: 使用的是http协议，性能与dubbo对比稍微差点 Dubbo: 是一款优秀的RPC框架，并发能力比springcloud强 (2) 注册中心 Spring Cloud: 有全家桶配置中心。eurake nacos,亦可以选择zookeeper Dubbo: 一般选择zookeeper (3) 分布式配置中心 Spring Cloud: nacos/ spring cloud config Dubbo: 阿波罗 (4) 网关 Spring Cloud: zuul / srping cloud gateway Dubbo: 需引入其他网关组件 (5) 负载均衡 Spring Cloud: ribbon Dubbo: 自带负载均衡 (6) 熔断功能 Spring Cloud: hystrix Dubbo: 需引入其他熔断框架 (7) 社区活跃度 Spring Cloud: 活跃、版本更新快 Dubbo: 不活跃 Tips   所以现在一般都会选择spring cloud 全家桶做微服务，因为spring cloud胜在功能更全，有一些列可以开箱即用的组件，满足服务化后的各种场 景需求。或者说dubbo就是一个纯正的RPC框架，对于服务之间远程调用，性能非常优秀，并发高，响应快，但是也仅仅是一个RPC框架，如果需要其他的 功能，则需要引入其他 的组件，因此在引入其他组件的过程中，可能会带来更多的问题。所以对于易用性这一块，spring cloud已经集成了各方面微服 务所需要的组件，上手更快，拆坑更少，团队上手更容易，学习成本更低。可以开箱即用，快速上手。 "},"pages/分布式/看过Dubbo源码吗.html":{"url":"pages/分布式/看过Dubbo源码吗.html","title":"看过Dubbo源码吗?说说Dubbo的底层架构原理?","keywords":"","body":" 简介   Dubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合(或者最大限度 地松耦合)。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出 服务提供方(Provider)和服务消费方(Consumer)两个角色。 是什么   简单说呢，Dubbo用起来就和EJB、WebService差不多，调用一个远程的服务(或者JavaBean)的时候在本地有一个接口，就像调用本地的 方法一样去调用，它底层帮你实现好你的方法参数传输和远程服务运行结果传回之后的返回，就是RPC的一种封装啦~ 特点 (1) 它主要是使用高效的网络框架和序列化框架，让分布式服务之间调用效率更高。 (2) 采用注册中心管理众多的服务接口地址，当你想调用服务的时候只需要跟注册中心询问即可，不用像使用WebService一样每个服务都得记录好接口 调用方式。注册中心主要就是负责dubbo的所有服务地址列表维护，并且可以通过在ZooKeeper节点中设置相应的值来实现对这个服务的权重、优先级、 是否可用、路由、权限等的控制。之后在Dubbo的管理控制台对服务的一堆治理策略设置和调整，实际上就是修改了注册中心中的服务对应的配置数据 (即修改了zookeeper中服务对应的节点的配置数据)。之后Consumer从注册中心请求到服务的数据时就能根据这些配置数据进行相应的治理配置参数的 代码执行生效。 (3) 监控中心实现对服务方和调用方之间运行状态的监控，还能控制服务的优先级、权限、权重、上下线等，让整个庞大的分布式服务系统的维护和治理 比较方便。 (4) 高可用有个服务宕机了?注册中心就会从服务列表去掉该节点。还是调用到了?客户端会向注册中心请求另一台可用的服务节点重新调用。注册中心宕 机?注册中心也能实现高可用(ZooKeeper)。 (5) 负载均衡：采用软负载均衡算法实现对多个相同服务的节点的请求负载均衡。 RPC之Dubbo实现   主要为三点，动态代理、反射、socket网络编程 (1) 客户端使用动态代理的方式，“假装”实现了createOrder方法。 (2) 方法相关的数据通过序列化，进入到socket服务器。dubbo的socket实现为Netty。 (3) 服务端从socket服务器取出数据，通过反射的方式找到“真实”的服务实现。 (4) 服务端的方法在服务启动时已注入。 (5) 服务发现层，可用zookeeper。zookeeper保证了CP(一致性，分区容错性)。缺点：master节点挂掉时，需要时间重新选择master，这段时间内注册 中心将不可用。 注意：服务端可消费端注册成功后，通讯只走socket服务器，不会经过注册中心。 核心技术简介 (1) 客户端发起接口调用 (2) 服务中间件进行路由选址：找到具体接口实现的服务地址 (3) 客户端将请求信息进行编码(序列化: 方法名，接口名，参数，版本号等) (4) 建立与服务端的通讯(不是调度中心，而是客户端与服务端直连) (5) 服务端将接收到的信息进行反编码(反序列化) (6) 根据信息找到服务端的接口实现类 (7) 将执行结果反馈给客户端 "},"pages/分布式/咱们来聊点深入的,说说Dubbo底层的网络通信机制原理.html":{"url":"pages/分布式/咱们来聊点深入的,说说Dubbo底层的网络通信机制原理.html","title":"咱们来聊点深入的,说说Dubbo底层的网络通信机制原理","keywords":"","body":" 基本信息 (1) 连接个数: 单连接 (2) 连接方式: 长连接 (3) 传输协议: TCP (4) 传输方式: NIO异步传输 (5) 序列化: Hessian二进制序列化 (6) 适用范围： 传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件 或超大字符串。 (7) 适用场景: 常规远程服务方法调用 同步远程调用 (1) 客户端线程调用远程接口，向服务端发送请求，同时当前线程应该处于“暂停“状态，即线程不能向后执行了，必需要拿到服务端给自己的结果后 才能向后执行 (2) 服务端接到客户端请求后，处理请求，将结果给客户端 (3) 客户端收到结果，然后当前线程继续往后执行 基本原理 (1) client一个线程调用远程接口，生成一个唯一的ID（比如一段随机字符串，UUID等），Dubbo是使用AtomicLong从0开始累计数字的 (2) 将打包的方法调用信息（如调用的接口名称，方法名称，参数值列表等），和处理结果的回调对象callback，全部封装在一起，组成一个对象object (3) 向专门存放调用信息的全局ConcurrentHashMap里面put(ID, object) (4) 将ID和打包的方法调用信息封装成一对象connRequest，使用IoSession.write(connRequest)异步发送出去 (5) 当前线程再使用callback的get()方法试图获取远程返回的结果，在get()内部，则使用synchronized获取回调对象callback的锁， 再先检 测是否已经获取到结果，如果没有，然后调用callback的wait()方法，释放callback上的锁，让当前线程处于等待状态。 (6) 服务端接收到请求并处理后，将结果（此结果中包含了前面的ID，即回传）发送给客户端，客户端socket连接上专门监听消息的线程收到消息， 分析结果，取到ID，再从前面的ConcurrentHashMap里面get(ID)，从而找到callback，将方法调用结果设置到callback对象里。 (7) 监听线程接着使用synchronized获取回调对象callback的锁（因为前面调用过wait()，那个线程已释放callback的锁了），再notifyAll()， 唤醒前面处于等待状态的线程继续执行（callback的get()方法继续执行就能拿到调用结果了,这里的callback对象是每次调用产生一个新的，不能共享， 否则会有问题；另外ID必需至少保证在一个Socket连接里面是唯一的。），至此，整个过程结束。 当前线程怎么让它“暂停”,等结果回来后,再向后执行?   答: 先生成一个对象obj，在一个全局map里put(ID,obj)存放起来，再用synchronized获取obj锁，再调用obj.wait()让当前线程处于等待状态，然 后另一消息监听线程等到服务端结果来了后，再map.get(ID)找到obj，再用synchronized获取obj锁，再调用obj.notifyAll()唤醒前面处于等待状态 的线程。 正如前面所说,Socket通信是一个全双工的方式,如果有多个线程同时进行远程方法调用,这时建立在client server之间的socket连接上会有很 多双方发送的消息传递,前后顺序也可能是乱七八糟的,server处理完结果后,将结果消息发送给client,client收到很多消息,怎么知道哪个消息结 果是原先哪个线程调用的?   答: 使用一个ID，让其唯一，然后传递给服务端，再服务端又回传回来，这样就知道结果是原先哪个线程的了。 "},"pages/分布式/Dubbo框架从架构设计角度,是怎么保证极高的可扩展性.html":{"url":"pages/分布式/Dubbo框架从架构设计角度,是怎么保证极高的可扩展性.html","title":"Dubbo框架从架构设计角度,是怎么保证极高的可扩展性","keywords":"","body":" Dubbo SPI特点 (1) 对Dubbo进行扩展，不需要改动Dubbo的源码。 (2) 自定义的Dubbo的扩展点实现，是一个普通的Java类，Dubbo没有引入任何Dubbo特有的元素，对代码侵入性几乎为零。 (3) 将扩展注册到Dubbo中，只需要在ClassPath中添加配置文件。使用简单。而且不会对现有代码造成影响。符合开闭原则。 (4) Dubbo的扩展机制支持IoC,AoP等高级功能。 (5) Dubbo的扩展机制能很好的支持第三方IoC容器，默认支持Spring Bean，可自己扩展来支持其他容器，比如Google的Guice。 (6) 切换扩展点的实现，只需要在配置文件中修改具体的实现，不需要改代码。使用方便。 Dubbo底层架构原理图 "},"pages/分布式/如果让你设计一个RPC框架,网络通信代理机制负载均衡.html":{"url":"pages/分布式/如果让你设计一个RPC框架,网络通信代理机制负载均衡.html","title":"如果让你设计一个RPC框架,网络通信 代理机制 负载均衡","keywords":"","body":" 什么是RPC   RPC的全称是Remote Procedure Call，远程过程调用。RPC框架有很多，比如hsf、dubbo等等。借助RPC框架，我们在写业务代码的时候可以不需 要去考虑服务之间的通信等问题，在调用远程服务的时候就像调用本地的方法那么简单。 组成部分 (1) 简化本地调用流程 既然我们要像调用本地方法那样调用远程服务， 那么就应该生成代理来隐藏调用远程服务的细节。 这些细节包括但不限于以下所列出的关注点。 (2) 服务发现与服务注册 (a) 如果我们想在Service A中调用Service B，那么我们首先得知道Service B的地址。 所以，我们需要有一个服务注册中心，通过这个中心，服务可以把自己的信息注册进来，也可以获取到别的服务的信息。 (b) 客户端也需要watch服务注册中心的目标服务的地址的变化。 (3) 网络通信 (a) 服务和服务之间的网络通信模型， NIO/IO等等 (b) 客户端如何复用与服务端的连接， 而不是每次请求都重新创建一个新连接？ (c) 客户端收到返回后，如何知道是哪个请求的返回并且做出正确处理？ (4) 消息的序列化 服务间通信的消息通过什么方式进行序列化？ hessian，XML、JSON、Protobuf、……, 甚至Java原生的序列化方式， 你总得选择一个。 (5) 负载均衡 客户端通过服务注册中心拿到一堆地址，该调哪个呢？最简单的方式，可以通过RR、WRR的方式去做LB。 (a) 根据服务实例的metrics做出动态调整, 比如响应时间等 (b) 利用一致性哈希， 提高本地缓存利用率 (6) 容灾 (a) 康监测： 在某一个服务节点挂掉的时候， 如何在服务注册中心删去这个服务地址？ (b) 服务调用超时与重试： 在调用一个服务实例的时候，如果超时或者报错，怎么处理？ (c) 服务限流：如何限制最大并发数？这个又可以从客户端和服务端两个角度分析。 "}}