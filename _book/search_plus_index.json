{"./":{"url":"./","title":"interview of sonin","keywords":"","body":"简介 Markdown基本操作    "},"pages/分布式/你们的系统使用了哪种服务框架为什么要这样技术选型.html":{"url":"pages/分布式/你们的系统使用了哪种服务框架为什么要这样技术选型.html","title":"你们的系统使用了哪种服务框架?为什么要这样技术选型?","keywords":"","body":" Spring Cloud & Dubbo对比 (1) 并发性能 Spring Cloud: 使用的是http协议，性能与dubbo对比稍微差点 Dubbo: 是一款优秀的RPC框架，并发能力比springcloud强 (2) 注册中心 Spring Cloud: 有全家桶配置中心。eurake nacos,亦可以选择zookeeper Dubbo: 一般选择zookeeper (3) 分布式配置中心 Spring Cloud: nacos/ spring cloud config Dubbo: 阿波罗 (4) 网关 Spring Cloud: zuul / srping cloud gateway Dubbo: 需引入其他网关组件 (5) 负载均衡 Spring Cloud: ribbon Dubbo: 自带负载均衡 (6) 熔断功能 Spring Cloud: hystrix Dubbo: 需引入其他熔断框架 (7) 社区活跃度 Spring Cloud: 活跃、版本更新快 Dubbo: 不活跃 Tips   所以现在一般都会选择spring cloud 全家桶做微服务，因为spring cloud胜在功能更全，有一些列可以开箱即用的组件，满足服务化后的各种场 景需求。或者说dubbo就是一个纯正的RPC框架，对于服务之间远程调用，性能非常优秀，并发高，响应快，但是也仅仅是一个RPC框架，如果需要其他的 功能，则需要引入其他 的组件，因此在引入其他组件的过程中，可能会带来更多的问题。所以对于易用性这一块，spring cloud已经集成了各方面微服 务所需要的组件，上手更快，拆坑更少，团队上手更容易，学习成本更低。可以开箱即用，快速上手。 "},"pages/分布式/看过Dubbo源码吗.html":{"url":"pages/分布式/看过Dubbo源码吗.html","title":"看过Dubbo源码吗?说说Dubbo的底层架构原理?","keywords":"","body":" 简介   Dubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合(或者最大限度 地松耦合)。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出 服务提供方(Provider)和服务消费方(Consumer)两个角色。 是什么   简单说呢，Dubbo用起来就和EJB、WebService差不多，调用一个远程的服务(或者JavaBean)的时候在本地有一个接口，就像调用本地的 方法一样去调用，它底层帮你实现好你的方法参数传输和远程服务运行结果传回之后的返回，就是RPC的一种封装啦~ 特点 (1) 它主要是使用高效的网络框架和序列化框架，让分布式服务之间调用效率更高。 (2) 采用注册中心管理众多的服务接口地址，当你想调用服务的时候只需要跟注册中心询问即可，不用像使用WebService一样每个服务都得记录好接口 调用方式。注册中心主要就是负责dubbo的所有服务地址列表维护，并且可以通过在ZooKeeper节点中设置相应的值来实现对这个服务的权重、优先级、 是否可用、路由、权限等的控制。之后在Dubbo的管理控制台对服务的一堆治理策略设置和调整，实际上就是修改了注册中心中的服务对应的配置数据 (即修改了zookeeper中服务对应的节点的配置数据)。之后Consumer从注册中心请求到服务的数据时就能根据这些配置数据进行相应的治理配置参数的 代码执行生效。 (3) 监控中心实现对服务方和调用方之间运行状态的监控，还能控制服务的优先级、权限、权重、上下线等，让整个庞大的分布式服务系统的维护和治理 比较方便。 (4) 高可用有个服务宕机了?注册中心就会从服务列表去掉该节点。还是调用到了?客户端会向注册中心请求另一台可用的服务节点重新调用。注册中心宕 机?注册中心也能实现高可用(ZooKeeper)。 (5) 负载均衡：采用软负载均衡算法实现对多个相同服务的节点的请求负载均衡。 RPC之Dubbo实现   主要为三点，动态代理、反射、socket网络编程 (1) 客户端使用动态代理的方式，“假装”实现了createOrder方法。 (2) 方法相关的数据通过序列化，进入到socket服务器。dubbo的socket实现为Netty。 (3) 服务端从socket服务器取出数据，通过反射的方式找到“真实”的服务实现。 (4) 服务端的方法在服务启动时已注入。 (5) 服务发现层，可用zookeeper。zookeeper保证了CP(一致性，分区容错性)。缺点：master节点挂掉时，需要时间重新选择master，这段时间内注册 中心将不可用。 注意：服务端可消费端注册成功后，通讯只走socket服务器，不会经过注册中心。 核心技术简介 (1) 客户端发起接口调用 (2) 服务中间件进行路由选址：找到具体接口实现的服务地址 (3) 客户端将请求信息进行编码(序列化: 方法名，接口名，参数，版本号等) (4) 建立与服务端的通讯(不是调度中心，而是客户端与服务端直连) (5) 服务端将接收到的信息进行反编码(反序列化) (6) 根据信息找到服务端的接口实现类 (7) 将执行结果反馈给客户端 "},"pages/分布式/咱们来聊点深入的,说说Dubbo底层的网络通信机制原理.html":{"url":"pages/分布式/咱们来聊点深入的,说说Dubbo底层的网络通信机制原理.html","title":"咱们来聊点深入的,说说Dubbo底层的网络通信机制原理?","keywords":"","body":" 基本信息 (1) 连接个数: 单连接 (2) 连接方式: 长连接 (3) 传输协议: TCP (4) 传输方式: NIO异步传输 (5) 序列化: Hessian二进制序列化 (6) 适用范围： 传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件 或超大字符串。 (7) 适用场景: 常规远程服务方法调用 同步远程调用 (1) 客户端线程调用远程接口，向服务端发送请求，同时当前线程应该处于“暂停“状态，即线程不能向后执行了，必需要拿到服务端给自己的结果后 才能向后执行 (2) 服务端接到客户端请求后，处理请求，将结果给客户端 (3) 客户端收到结果，然后当前线程继续往后执行 基本原理 (1) client一个线程调用远程接口，生成一个唯一的ID（比如一段随机字符串，UUID等），Dubbo是使用AtomicLong从0开始累计数字的 (2) 将打包的方法调用信息（如调用的接口名称，方法名称，参数值列表等），和处理结果的回调对象callback，全部封装在一起，组成一个对象object (3) 向专门存放调用信息的全局ConcurrentHashMap里面put(ID, object) (4) 将ID和打包的方法调用信息封装成一对象connRequest，使用IoSession.write(connRequest)异步发送出去 (5) 当前线程再使用callback的get()方法试图获取远程返回的结果，在get()内部，则使用synchronized获取回调对象callback的锁， 再先检 测是否已经获取到结果，如果没有，然后调用callback的wait()方法，释放callback上的锁，让当前线程处于等待状态。 (6) 服务端接收到请求并处理后，将结果（此结果中包含了前面的ID，即回传）发送给客户端，客户端socket连接上专门监听消息的线程收到消息， 分析结果，取到ID，再从前面的ConcurrentHashMap里面get(ID)，从而找到callback，将方法调用结果设置到callback对象里。 (7) 监听线程接着使用synchronized获取回调对象callback的锁（因为前面调用过wait()，那个线程已释放callback的锁了），再notifyAll()， 唤醒前面处于等待状态的线程继续执行（callback的get()方法继续执行就能拿到调用结果了,这里的callback对象是每次调用产生一个新的，不能共享， 否则会有问题；另外ID必需至少保证在一个Socket连接里面是唯一的。），至此，整个过程结束。 当前线程怎么让它“暂停”,等结果回来后,再向后执行?   答: 先生成一个对象obj，在一个全局map里put(ID,obj)存放起来，再用synchronized获取obj锁，再调用obj.wait()让当前线程处于等待状态，然 后另一消息监听线程等到服务端结果来了后，再map.get(ID)找到obj，再用synchronized获取obj锁，再调用obj.notifyAll()唤醒前面处于等待状态 的线程。 正如前面所说,Socket通信是一个全双工的方式,如果有多个线程同时进行远程方法调用,这时建立在client server之间的socket连接上会有很 多双方发送的消息传递,前后顺序也可能是乱七八糟的,server处理完结果后,将结果消息发送给client,client收到很多消息,怎么知道哪个消息结 果是原先哪个线程调用的?   答: 使用一个ID，让其唯一，然后传递给服务端，再服务端又回传回来，这样就知道结果是原先哪个线程的了。 "},"pages/分布式/Dubbo框架从架构设计角度,是怎么保证极高的可扩展性.html":{"url":"pages/分布式/Dubbo框架从架构设计角度,是怎么保证极高的可扩展性.html","title":"Dubbo框架从架构设计角度,是怎么保证极高的可扩展性?","keywords":"","body":" Dubbo SPI特点 (1) 对Dubbo进行扩展，不需要改动Dubbo的源码。 (2) 自定义的Dubbo的扩展点实现，是一个普通的Java类，Dubbo没有引入任何Dubbo特有的元素，对代码侵入性几乎为零。 (3) 将扩展注册到Dubbo中，只需要在ClassPath中添加配置文件。使用简单。而且不会对现有代码造成影响。符合开闭原则。 (4) Dubbo的扩展机制支持IoC,AoP等高级功能。 (5) Dubbo的扩展机制能很好的支持第三方IoC容器，默认支持Spring Bean，可自己扩展来支持其他容器，比如Google的Guice。 (6) 切换扩展点的实现，只需要在配置文件中修改具体的实现，不需要改代码。使用方便。 Dubbo底层架构原理图 "},"pages/分布式/如果让你设计一个RPC框架,网络通信代理机制负载均衡.html":{"url":"pages/分布式/如果让你设计一个RPC框架,网络通信代理机制负载均衡.html","title":"如果让你设计一个RPC框架,网络通信 代理机制 负载均衡?","keywords":"","body":" 什么是RPC   RPC的全称是Remote Procedure Call，远程过程调用。RPC框架有很多，比如hsf、dubbo等等。借助RPC框架，我们在写业务代码的时候可以不需 要去考虑服务之间的通信等问题，在调用远程服务的时候就像调用本地的方法那么简单。 组成部分 (1) 简化本地调用流程 既然我们要像调用本地方法那样调用远程服务， 那么就应该生成代理来隐藏调用远程服务的细节。 这些细节包括但不限于以下所列出的关注点。 (2) 服务发现与服务注册 (a) 如果我们想在Service A中调用Service B，那么我们首先得知道Service B的地址。 所以，我们需要有一个服务注册中心，通过这个中心，服务可以把自己的信息注册进来，也可以获取到别的服务的信息。 (b) 客户端也需要watch服务注册中心的目标服务的地址的变化。 (3) 网络通信 (a) 服务和服务之间的网络通信模型， NIO/IO等等 (b) 客户端如何复用与服务端的连接， 而不是每次请求都重新创建一个新连接？ (c) 客户端收到返回后，如何知道是哪个请求的返回并且做出正确处理？ (4) 消息的序列化 服务间通信的消息通过什么方式进行序列化？ hessian，XML、JSON、Protobuf、……, 甚至Java原生的序列化方式， 你总得选择一个。 (5) 负载均衡 客户端通过服务注册中心拿到一堆地址，该调哪个呢？最简单的方式，可以通过RR、WRR的方式去做LB。 (a) 根据服务实例的metrics做出动态调整, 比如响应时间等 (b) 利用一致性哈希， 提高本地缓存利用率 (6) 容灾 (a) 康监测： 在某一个服务节点挂掉的时候， 如何在服务注册中心删去这个服务地址？ (b) 服务调用超时与重试： 在调用一个服务实例的时候，如果超时或者报错，怎么处理？ (c) 服务限流：如何限制最大并发数？这个又可以从客户端和服务端两个角度分析。 "},"pages/分布式/平时除了使用外有研究过SpringCloud的底层架构原理吗.html":{"url":"pages/分布式/平时除了使用外有研究过SpringCloud的底层架构原理吗.html","title":"平时除了使用外,有研究过Spring Cloud的底层架构原理吗?","keywords":"","body":" SpringCloud架构原理图 Spring Cloud核心组件 (1) Eureka 各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里 (2) Ribbon 服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台 (3) Feign 基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求 (4) Hystrix 发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题 (5) Zuul 如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务 "},"pages/分布式/从底层实现原理的角度对比一下Dubbo和SpringCloud的区别.html":{"url":"pages/分布式/从底层实现原理的角度对比一下Dubbo和SpringCloud的区别.html","title":"从底层实现原理的角度,对比一下Dubbo和Spring Cloud的区别?","keywords":"","body":" 相同点   都需要 服务提供方，注册中心，服务消费方。 Dubbo (1) Provider: 暴露服务的提供方，可以通过jar或者容器的方式启动服务。 (2) Consumer: 调用远程服务的服务消费方。 (3) Registry: 服务注册中心和发现中心。 (4) Monitor: 统计服务和调用次数，调用时间监控中心。(dubbo的控制台页面中可以显示，目前只有一个简单版本) (5) Container: 服务运行的容器。 Spring Cloud (1) Service Provider: 暴露服务的提供方。 (2) Service Consumer: 调用远程服务的服务消费方。 (3) EureKa Server: 服务注册中心和服务发现中心。 比较 (1) 从核心要素来看   Spring Cloud 更胜一筹，在开发过程中只要整合Spring Cloud的子项目就可以顺利的完成各种组件的融合，而Dubbo缺需要通过实现各种Filter 来做定制，开发成本以及技术难度略高。Dubbo只是实现了服务治理，而Spring Cloud子项目分别覆盖了微服务架构下的众多部件，而服务治理只是其中 的一个方面。Dubbo提供了各种Filter，对于上述中“无”的要素，可以通过扩展Filter来完善。   e.g (a) 分布式配置：可以使用淘宝的diamond、百度的disconf来实现分布式配置管理 (b) 服务跟踪：可以使用京东开源的Hydra，或者扩展Filter用Zippin来做服务跟踪 (c) 批量任务：可以使用当当开源的Elastic-Job、tbschedule (2) 从协议上看   Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况，二进 制的传输，占用带宽会更少。Spring Cloud 使用HTTP协议的REST APIdubbo支持各种通信协议，而且消费方和服务方使用长链接方式交互，http协议 传输，消耗带宽会比较多，同时使用http协议一般会使用JSON报文，消耗会更大。通信速度上Dubbo略胜Spring Cloud，如果对于系统的响应时间有严 格要求，长链接更合适。 (3) 从服务依赖方式看   Dubbo服务依赖略重，需要有完善的版本管理机制，但是程序入侵少。而Spring Cloud通过Json交互，省略了版本管理的问题，但是具体字段含义需 要统一管理，自身Rest API方式交互，为跨平台调用奠定了基础。 (4) 从组件运行流程看   Dubbo每个组件都是需要部署在单独的服务器上，gateway用来接受前端请求、聚合服务，并批量调用后台原子服务。每个service层和单独的DB交互。   SpringCloud所有请求都统一通过 API 网关（Zuul）来访问内部服务。网关接收到请求后，从注册中心（Eureka）获取可用服务。由 Ribbon 进行 均衡负载后，分发到后端的具体实例。微服务之间通过 Feign 进行通信处理业务。业务部署方式相同，都需要前置一个网关来隔绝外部直接调用原子服务 的风险。Dubbo需要自己开发一套API 网关，而Spring Cloud则可以通过Zuul配置即可完成网关定制。使用方式上Spring Cloud略胜一筹。 "}}