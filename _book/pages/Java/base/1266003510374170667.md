#### 源码解析

```
// JDK1.8以后的HashMap里面的一段源码
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

#### 运算

高低16位参与运算:
```
比如有一个key的hash值:
    原值: 1111 1111 1111 1111     1111 1010 0111 1100
    右移16位:  0000 0000 0000 0000  1111 1111 1111 1111
    异或运算:   1111 1111 1111 1111     0000 0101 1000 0011 -> 转换成int值表示hash值
    寻址算法优化: (n - 1) & hash  -> 算出数组里的一个位置下标
```
<div style="text-indent:2em">取模运算性能差一些，为了优化数组寻址过程，数组长度2的n次方，hash & (n – 1)效果跟hash对n取模效果一样，与运算性能更高。核心在于低16的与运算。</div>


#### hash算法的优化
<div style="text-indent:2em">对每个hash值，在他的低16位中，让高低16位进行了异或，让他的低16位同时保持了高低16位的特征，尽量避免一些hash值后续出现冲突，大家可能会进入数组的同一个位置。</div>
