#### 什么是RPC
<div style="text-indent:2em">RPC的全称是Remote Procedure Call，远程过程调用。RPC框架有很多，比如hsf、dubbo等等。借助RPC框架，我们在写业务代码的时候可以不需要去考虑服务之间的通信等问题，在调用远程服务的时候就像调用本地的方法那么简单。</div>

#### 组成部分
* 简化本地调用流程
<div style="text-indent:2em">既然我们要像调用本地方法那样调用远程服务， 那么就应该生成代理来隐藏调用远程服务的细节。 这些细节包括但不限于以下所列出的关注点。</div>
* 服务发现与服务注册
    1. 如果我们想在Service A中调用Service B，那么我们首先得知道Service B的地址。 所以，我们需要有一个服务注册中心，通过这个中心，服务可以把自己的信息注册进来，也可以获取到别的服务的信息。
    2. 客户端也需要watch服务注册中心的目标服务的地址的变化。
* 网络通信
    1. 服务和服务之间的网络通信模型， NIO/IO等等
    2. 客户端如何复用与服务端的连接， 而不是每次请求都重新创建一个新连接？
    3. 客户端收到返回后，如何知道是哪个请求的返回并且做出正确处理？
* 消息的序列化
<div style="text-indent:2em">服务间通信的消息通过什么方式进行序列化？ hessian，XML、JSON、Protobuf、……, 甚至Java原生的序列化方式， 你总得选择一个。</div>
* 负载均衡
<div style="text-indent:2em">客户端通过服务注册中心拿到一堆地址，该调哪个呢？最简单的方式，可以通过RR、WRR的方式去做LB。</div>
    1. 根据服务实例的metrics做出动态调整, 比如响应时间等
    2. 利用一致性哈希， 提高本地缓存利用率
* 容灾
    1. 健康监测: 在某一个服务节点挂掉的时候， 如何在服务注册中心删去这个服务地址？
    2. 服务调用超时与重试: 在调用一个服务实例的时候，如果超时或者报错，怎么处理？
    3. 服务限流: 如何限制最大并发数？这个又可以从客户端和服务端两个角度分析。
