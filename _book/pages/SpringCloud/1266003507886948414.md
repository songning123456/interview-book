#### 解决思路
<div style="text-indent:2em">每天服务多少请求量，高峰每秒qps，在代码里稍微加一些metrics代码，对自己运行过程中各种请求量，每秒请求量，成功次数，失败次数，在内存里直接做一些计数。在负责的核心服务里，核心接口，开发一个简单的metric统计机制，AtomicLong，保证原则性，并发数据统计准确。每个接口被调用时，可以对每个接口每分钟做一个metric统计，每个接口每天统计计数。再通过Log4j, logback等日志组件，把次数直接打印到日志文件，统计出高峰期每秒系统被访问的次数，每条每个接口访问量。</div>

#### 响应延时
<div style="text-indent:2em">计算一下每个接口从请求到执行完毕，需要耗费多长时间，算一下每个接口平均的请求延时，TP99，TP95，TP90，TP50，TP99，99%的请求耗费的时间在100ms以内，但是1%的请求可能耗费的时间在100ms以上TP99 = 100ms TP95 = 50ms，95%的请求耗费的时间多在50ms以内，但是5%的请求耗费的时间在50ms以上压测工具，java压测工具，开源的可以用的，模拟出来同时有多少用户发起多少请求，每秒发起1000请求能抗住吗？每秒钟发起2000请求能抗住吗？假设你的系统每秒钟最多抗800请求，如果你的压测工具每秒发起了1000个请求，此时会发现最多只有800个请求同时可以被处理，剩余200个请求需要进行排队被阻塞住了，表示你这个系统每秒钟最多抗800个请求。</div>
